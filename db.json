{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/webpack-intro.png","path":"images/webpack-intro.png","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"495dc0d217dbc3e7cb0c015a4aa9af3e7011d37f","modified":1688447103401},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1688382403488},{"_id":"source/about/index.md","hash":"59a6637f28c77c073099f79d29287978c46d4954","modified":1688374768386},{"_id":"source/_posts/webpack/intro.md","hash":"bd416dfbec9585cdff0800b4622ffea7876b529d","modified":1688379758614},{"_id":"source/images/webpack-intro.png","hash":"47645d00bb74283fbbf7cbe3891a72e084c56990","modified":1686910776837},{"_id":"source/_posts/webpack/loader.md","hash":"2c8cfa092ecf485edfd19ec25e8d67ebf764a112","modified":1688379770323},{"_id":"source/_posts/webpack/loader-principle.md","hash":"330abb44703578d9a633d410bc7e87f9b071990c","modified":1688379790419},{"_id":"source/_posts/webpack/plugin.md","hash":"356d03047ba5d4ebbb9300224590aa384508da15","modified":1688454117425},{"_id":"node_modules/hexo-theme-aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"1b312a6a2de107ba9dc952614f1078c78664a4e4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1688369607769}],"Category":[{"name":"构建工具","_id":"cljo05xhx0003322z3yxv71pz"}],"Data":[],"Page":[{"title":"about","date":"2023-07-03T07:46:53.000Z","_content":"\n- hello about page","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-07-03 15:46:53\n---\n\n- hello about page","updated":"2023-07-03T08:59:28.386Z","path":"about/index.html","comments":1,"layout":"page","_id":"cljo05xhp0000322z0t8o6ivt","content":"<ul>\n<li>hello about page</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>hello about page</li>\n</ul>\n"}],"Post":[{"title":"Webpack Loader 实现原理","date":"2023-06-23T09:46:40.000Z","_content":"\n## 1. Loader是什么\n\n前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~\n\n## 2. Loader链式调用\n\n理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会``从右向左、从下到上``的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。\n\n## 3. Loader的实现方式\n\nWebpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。\n\n### 3.1 函数式 Loader\n\n这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。\n\n```javascript\nmodule.exports = function(source) {\n  const options = this.getOptions(); // loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  // 处理文件内容的逻辑\n  let transformSource = source\n  // 返回处理后的内容\n  return transformSource\n}\n```\n\n### 3.2 对象式Loader\n\n相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。\n\n```javascript\nmodule.exports = {\n  pitch: function(remainingRequest, precedingRequest, data) {\n    // pitch方法的处理逻辑\n    // 可以进行一些预处理或提前返回结果\n  },\n  loader: function(content, map, meta) {\n    // loader方法的处理逻辑\n    // 进行文件内容的转换和处理\n    // 返回处理后的内容\n    return transformedContent;\n  }\n}\n```\n\n### 3.3 在 Webpack 中如何使用自定义 Loader\n\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  resolveLoader: {\n    modules: ['node_modules', path.resolve(__dirname, 'loaders')], // loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          'your-loadername',\n        ]\n      }\n    ]\n  }\n};\n```\n\n## 4. 缓存和性能优化\n为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。\n","source":"_posts/webpack/loader-principle.md","raw":"---\ntitle: Webpack Loader 实现原理\ndate: 2023-06-23 17:46:40\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\n## 1. Loader是什么\n\n前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~\n\n## 2. Loader链式调用\n\n理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会``从右向左、从下到上``的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。\n\n## 3. Loader的实现方式\n\nWebpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。\n\n### 3.1 函数式 Loader\n\n这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。\n\n```javascript\nmodule.exports = function(source) {\n  const options = this.getOptions(); // loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  // 处理文件内容的逻辑\n  let transformSource = source\n  // 返回处理后的内容\n  return transformSource\n}\n```\n\n### 3.2 对象式Loader\n\n相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。\n\n```javascript\nmodule.exports = {\n  pitch: function(remainingRequest, precedingRequest, data) {\n    // pitch方法的处理逻辑\n    // 可以进行一些预处理或提前返回结果\n  },\n  loader: function(content, map, meta) {\n    // loader方法的处理逻辑\n    // 进行文件内容的转换和处理\n    // 返回处理后的内容\n    return transformedContent;\n  }\n}\n```\n\n### 3.3 在 Webpack 中如何使用自定义 Loader\n\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  resolveLoader: {\n    modules: ['node_modules', path.resolve(__dirname, 'loaders')], // loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          'your-loadername',\n        ]\n      }\n    ]\n  }\n};\n```\n\n## 4. 缓存和性能优化\n为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。\n","slug":"webpack/loader-principle","published":1,"updated":"2023-07-03T10:23:10.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xhs0001322z4u4r9qol","content":"<h2 id=\"1-Loader是什么\"><a href=\"#1-Loader是什么\" class=\"headerlink\" title=\"1. Loader是什么\"></a>1. Loader是什么</h2><p>前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~</p>\n<h2 id=\"2-Loader链式调用\"><a href=\"#2-Loader链式调用\" class=\"headerlink\" title=\"2. Loader链式调用\"></a>2. Loader链式调用</h2><p>理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会<code>从右向左、从下到上</code>的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。</p>\n<h2 id=\"3-Loader的实现方式\"><a href=\"#3-Loader的实现方式\" class=\"headerlink\" title=\"3. Loader的实现方式\"></a>3. Loader的实现方式</h2><p>Webpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。</p>\n<h3 id=\"3-1-函数式-Loader\"><a href=\"#3-1-函数式-Loader\" class=\"headerlink\" title=\"3.1 函数式 Loader\"></a>3.1 函数式 Loader</h3><p>这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; function(source) &#123;\n  const options &#x3D; this.getOptions(); &#x2F;&#x2F; loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  &#x2F;&#x2F; 处理文件内容的逻辑\n  let transformSource &#x3D; source\n  &#x2F;&#x2F; 返回处理后的内容\n  return transformSource\n&#125;</code></pre>\n\n<h3 id=\"3-2-对象式Loader\"><a href=\"#3-2-对象式Loader\" class=\"headerlink\" title=\"3.2 对象式Loader\"></a>3.2 对象式Loader</h3><p>相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  pitch: function(remainingRequest, precedingRequest, data) &#123;\n    &#x2F;&#x2F; pitch方法的处理逻辑\n    &#x2F;&#x2F; 可以进行一些预处理或提前返回结果\n  &#125;,\n  loader: function(content, map, meta) &#123;\n    &#x2F;&#x2F; loader方法的处理逻辑\n    &#x2F;&#x2F; 进行文件内容的转换和处理\n    &#x2F;&#x2F; 返回处理后的内容\n    return transformedContent;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-在-Webpack-中如何使用自定义-Loader\"><a href=\"#3-3-在-Webpack-中如何使用自定义-Loader\" class=\"headerlink\" title=\"3.3 在 Webpack 中如何使用自定义 Loader\"></a>3.3 在 Webpack 中如何使用自定义 Loader</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  resolveLoader: &#123;\n    modules: [&#39;node_modules&#39;, path.resolve(__dirname, &#39;loaders&#39;)], &#x2F;&#x2F; loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;,\n        use: [\n          &#39;your-loadername&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"4-缓存和性能优化\"><a href=\"#4-缓存和性能优化\" class=\"headerlink\" title=\"4. 缓存和性能优化\"></a>4. 缓存和性能优化</h2><p>为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Loader是什么\"><a href=\"#1-Loader是什么\" class=\"headerlink\" title=\"1. Loader是什么\"></a>1. Loader是什么</h2><p>前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~</p>\n<h2 id=\"2-Loader链式调用\"><a href=\"#2-Loader链式调用\" class=\"headerlink\" title=\"2. Loader链式调用\"></a>2. Loader链式调用</h2><p>理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会<code>从右向左、从下到上</code>的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。</p>\n<h2 id=\"3-Loader的实现方式\"><a href=\"#3-Loader的实现方式\" class=\"headerlink\" title=\"3. Loader的实现方式\"></a>3. Loader的实现方式</h2><p>Webpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。</p>\n<h3 id=\"3-1-函数式-Loader\"><a href=\"#3-1-函数式-Loader\" class=\"headerlink\" title=\"3.1 函数式 Loader\"></a>3.1 函数式 Loader</h3><p>这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; function(source) &#123;\n  const options &#x3D; this.getOptions(); &#x2F;&#x2F; loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  &#x2F;&#x2F; 处理文件内容的逻辑\n  let transformSource &#x3D; source\n  &#x2F;&#x2F; 返回处理后的内容\n  return transformSource\n&#125;</code></pre>\n\n<h3 id=\"3-2-对象式Loader\"><a href=\"#3-2-对象式Loader\" class=\"headerlink\" title=\"3.2 对象式Loader\"></a>3.2 对象式Loader</h3><p>相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  pitch: function(remainingRequest, precedingRequest, data) &#123;\n    &#x2F;&#x2F; pitch方法的处理逻辑\n    &#x2F;&#x2F; 可以进行一些预处理或提前返回结果\n  &#125;,\n  loader: function(content, map, meta) &#123;\n    &#x2F;&#x2F; loader方法的处理逻辑\n    &#x2F;&#x2F; 进行文件内容的转换和处理\n    &#x2F;&#x2F; 返回处理后的内容\n    return transformedContent;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-在-Webpack-中如何使用自定义-Loader\"><a href=\"#3-3-在-Webpack-中如何使用自定义-Loader\" class=\"headerlink\" title=\"3.3 在 Webpack 中如何使用自定义 Loader\"></a>3.3 在 Webpack 中如何使用自定义 Loader</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  resolveLoader: &#123;\n    modules: [&#39;node_modules&#39;, path.resolve(__dirname, &#39;loaders&#39;)], &#x2F;&#x2F; loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;,\n        use: [\n          &#39;your-loadername&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"4-缓存和性能优化\"><a href=\"#4-缓存和性能优化\" class=\"headerlink\" title=\"4. 缓存和性能优化\"></a>4. 缓存和性能优化</h2><p>为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。</p>\n"},{"title":"Webpack 入门介绍","date":"2023-06-20T07:46:53.000Z","_content":"\nWebpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。\n\n<!-- more -->\n\n## 前言\n\n在过去的前端开发中，经常会使用的主要构建工具是 [``Gulp``](https://gulpjs.com/) 和 [``Grunt``](https://gruntjs.com/)。它们是基于任务（Stream / Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。\n\nGulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。\n\n然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。\n\nWebpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。\n\n## 1. 简介\n\nWebpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  \n\nWebpack 的主要优势包括：\n- ```模块化支持```：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。\n- ```强大的插件系统```：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。\n- ```开发环境支持```：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。\n- ```强大的生态系统```：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。\n\n![webpack-intro.png](/images/webpack-intro.png)\n\n## 2. 安装与使用\n\n### 2.1 安装\n\n接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，\n\n:::warning\n注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。\n:::\n  \n<br />\n\n```shell\n\nmkdir webpack-demo && cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D\n```\n\n```\n├── package.json\n├── package-lock.json\n└── src\n    └── index.js\n```\n\n然后我们更新一下 ``package.json`` ：\n\n```shell\n{\n  \"name\": \"webpack-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"  // 新增\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.87.0\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n}\n```\n接着我们在终端执行 ``npm run build``，webpack 会自动以 ``src`` 目录下的 ``index.js`` 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：\n\n```shell\n├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js\n```\n\n\n### 2.2 使用配置文件\n\n我们在项目下新建 ``webpack.config.js`` 文件来作为 webpack 的配置文件，然后同样执行 ``npm run build``\n\n```javascript\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.js', // 入口文件\n  output: {\n    filename: 'main.js', // bundle 文件名\n    path: path.resolve(__dirname, 'dist') // bundle 目录\n  }\n}\n```\n这一段基本配置，和我们在上一步中直接执行 ``npm run build`` 功能是一样的，都会在当前目录下生成一个 ``dist`` 目录及对应的打包出来的 bundle 文件。\n","source":"_posts/webpack/intro.md","raw":"---\ntitle: Webpack 入门介绍\ndate: 2023-06-20 15:46:53\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\nWebpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。\n\n<!-- more -->\n\n## 前言\n\n在过去的前端开发中，经常会使用的主要构建工具是 [``Gulp``](https://gulpjs.com/) 和 [``Grunt``](https://gruntjs.com/)。它们是基于任务（Stream / Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。\n\nGulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。\n\n然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。\n\nWebpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。\n\n## 1. 简介\n\nWebpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  \n\nWebpack 的主要优势包括：\n- ```模块化支持```：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。\n- ```强大的插件系统```：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。\n- ```开发环境支持```：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。\n- ```强大的生态系统```：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。\n\n![webpack-intro.png](/images/webpack-intro.png)\n\n## 2. 安装与使用\n\n### 2.1 安装\n\n接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，\n\n:::warning\n注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。\n:::\n  \n<br />\n\n```shell\n\nmkdir webpack-demo && cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D\n```\n\n```\n├── package.json\n├── package-lock.json\n└── src\n    └── index.js\n```\n\n然后我们更新一下 ``package.json`` ：\n\n```shell\n{\n  \"name\": \"webpack-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"  // 新增\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.87.0\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n}\n```\n接着我们在终端执行 ``npm run build``，webpack 会自动以 ``src`` 目录下的 ``index.js`` 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：\n\n```shell\n├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js\n```\n\n\n### 2.2 使用配置文件\n\n我们在项目下新建 ``webpack.config.js`` 文件来作为 webpack 的配置文件，然后同样执行 ``npm run build``\n\n```javascript\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.js', // 入口文件\n  output: {\n    filename: 'main.js', // bundle 文件名\n    path: path.resolve(__dirname, 'dist') // bundle 目录\n  }\n}\n```\n这一段基本配置，和我们在上一步中直接执行 ``npm run build`` 功能是一样的，都会在当前目录下生成一个 ``dist`` 目录及对应的打包出来的 bundle 文件。\n","slug":"webpack/intro","published":1,"updated":"2023-07-03T10:22:38.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xhv0002322zdvtod7w8","content":"<p>Webpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在过去的前端开发中，经常会使用的主要构建工具是 <a href=\"https://gulpjs.com/\"><code>Gulp</code></a> 和 <a href=\"https://gruntjs.com/\"><code>Grunt</code></a>。它们是基于任务（Stream &#x2F; Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。</p>\n<p>Gulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。</p>\n<p>然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。</p>\n<p>Webpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>Webpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  </p>\n<p>Webpack 的主要优势包括：</p>\n<ul>\n<li><code>模块化支持</code>：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。</li>\n<li><code>强大的插件系统</code>：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。</li>\n<li><code>开发环境支持</code>：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。</li>\n<li><code>强大的生态系统</code>：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。</li>\n</ul>\n<p><img src=\"/images/webpack-intro.png\" alt=\"webpack-intro.png\"></p>\n<h2 id=\"2-安装与使用\"><a href=\"#2-安装与使用\" class=\"headerlink\" title=\"2. 安装与使用\"></a>2. 安装与使用</h2><h3 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h3><p>接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。</p>\n</div>\n<br />\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\nmkdir webpack-demo &amp;&amp; cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">├── package.json\n├── package-lock.json\n└── src\n    └── index.js</code></pre>\n\n<p>然后我们更新一下 <code>package.json</code> ：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#123;\n  &quot;name&quot;: &quot;webpack-demo&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;  &#x2F;&#x2F; 新增\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;webpack&quot;: &quot;^5.87.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^5.1.4&quot;\n  &#125;\n&#125;</code></pre>\n<p>接着我们在终端执行 <code>npm run build</code>，webpack 会自动以 <code>src</code> 目录下的 <code>index.js</code> 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js</code></pre>\n\n\n<h3 id=\"2-2-使用配置文件\"><a href=\"#2-2-使用配置文件\" class=\"headerlink\" title=\"2.2 使用配置文件\"></a>2.2 使用配置文件</h3><p>我们在项目下新建 <code>webpack.config.js</code> 文件来作为 webpack 的配置文件，然后同样执行 <code>npm run build</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;)\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 入口文件\n  output: &#123;\n    filename: &#39;main.js&#39;, &#x2F;&#x2F; bundle 文件名\n    path: path.resolve(__dirname, &#39;dist&#39;) &#x2F;&#x2F; bundle 目录\n  &#125;\n&#125;</code></pre>\n<p>这一段基本配置，和我们在上一步中直接执行 <code>npm run build</code> 功能是一样的，都会在当前目录下生成一个 <code>dist</code> 目录及对应的打包出来的 bundle 文件。</p>\n","site":{"data":{}},"excerpt":"<p>Webpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。</p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在过去的前端开发中，经常会使用的主要构建工具是 <a href=\"https://gulpjs.com/\"><code>Gulp</code></a> 和 <a href=\"https://gruntjs.com/\"><code>Grunt</code></a>。它们是基于任务（Stream &#x2F; Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。</p>\n<p>Gulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。</p>\n<p>然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。</p>\n<p>Webpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>Webpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  </p>\n<p>Webpack 的主要优势包括：</p>\n<ul>\n<li><code>模块化支持</code>：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。</li>\n<li><code>强大的插件系统</code>：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。</li>\n<li><code>开发环境支持</code>：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。</li>\n<li><code>强大的生态系统</code>：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。</li>\n</ul>\n<p><img src=\"/images/webpack-intro.png\" alt=\"webpack-intro.png\"></p>\n<h2 id=\"2-安装与使用\"><a href=\"#2-安装与使用\" class=\"headerlink\" title=\"2. 安装与使用\"></a>2. 安装与使用</h2><h3 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h3><p>接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，</p>\n<p>:::warning<br>注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。<br>:::</p>\n<br />\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\nmkdir webpack-demo &amp;&amp; cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">├── package.json\n├── package-lock.json\n└── src\n    └── index.js</code></pre>\n\n<p>然后我们更新一下 <code>package.json</code> ：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#123;\n  &quot;name&quot;: &quot;webpack-demo&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;  &#x2F;&#x2F; 新增\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;webpack&quot;: &quot;^5.87.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^5.1.4&quot;\n  &#125;\n&#125;</code></pre>\n<p>接着我们在终端执行 <code>npm run build</code>，webpack 会自动以 <code>src</code> 目录下的 <code>index.js</code> 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js</code></pre>\n\n\n<h3 id=\"2-2-使用配置文件\"><a href=\"#2-2-使用配置文件\" class=\"headerlink\" title=\"2.2 使用配置文件\"></a>2.2 使用配置文件</h3><p>我们在项目下新建 <code>webpack.config.js</code> 文件来作为 webpack 的配置文件，然后同样执行 <code>npm run build</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;)\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 入口文件\n  output: &#123;\n    filename: &#39;main.js&#39;, &#x2F;&#x2F; bundle 文件名\n    path: path.resolve(__dirname, &#39;dist&#39;) &#x2F;&#x2F; bundle 目录\n  &#125;\n&#125;</code></pre>\n<p>这一段基本配置，和我们在上一步中直接执行 <code>npm run build</code> 功能是一样的，都会在当前目录下生成一个 <code>dist</code> 目录及对应的打包出来的 bundle 文件。</p>"},{"title":"Webpack Loader的学习与使用","date":"2023-06-22T02:46:55.000Z","_content":"\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 Loader ?\n\nLoader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。\nLoader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。\n\n## 2. 常用 loader 及其配置应用\n\n### 2.1 babel-loader\n\nbabel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 [``Babel``](https://babeljs.io/) 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。\n\n安装：\n\n```shell\nnpm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n配置：\n```javascript\n// webpack.config.js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']  // 使用@babel/preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel/preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。\n\n\n### 2.2 css-loader style-loader\n\ncss-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;\nstyle-loader 的作用是将 CSS 样式以 ``<style>`` 标签的形式插入到 HTML 页面中。\n\n安装：\n```shell\nnpm install css-loader style-loader -D\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader' // 将CSS文件转换为JavaScript模块\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.3 sass-loader less-loader\n\nsass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。\n\n- sass-loader \n\n安装：\n\n```shell\nnpm install sass-loader dart-sass --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.scss$/, // 匹配以.scss结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'sass-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n- less-loader\n\n安装：\n\n```shell\nnpm install less-loader less --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.less/, // 匹配以.less结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.4 postcss-loader\n\npostcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。[``PostCSS``](https://www.postcss.com.cn/) 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。\n\n安装：\n\n```shell\nnpm install postcss-loader postcss autoprefixer cssnano --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader', // 将CSS文件转换为JavaScript模块\n          'postcss-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n\n```javascript\n// postcss.config.js\nmodule.exports = {\n  plugins: [\n    require('autoprefixer'),\n    require('cssnano')\n  ]\n};\n```\n\n### 2.4 file-loader url-loader \n\nfile-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：\n\n``file-loader:``\n\n- 将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。\n- 适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。\n- 返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。\n\n``url-loader:``\n\n- 将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，\n则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。\n\n:::warning\nWebpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader\n:::\n\n[资源模块](https://webpack.docschina.org/guides/asset-modules/#root)\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.png/,\n        type: 'asset/resource'\n      }\n    ]\n  }\n};\n```\n\n\n### 2.5 thread-loader\n\nthread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。\n\n安装：\n\n```shell\nnpm install thread-loader --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n","source":"_posts/webpack/loader.md","raw":"---\ntitle: Webpack Loader的学习与使用\ndate: 2023-06-22 10:46:55\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 Loader ?\n\nLoader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。\nLoader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。\n\n## 2. 常用 loader 及其配置应用\n\n### 2.1 babel-loader\n\nbabel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 [``Babel``](https://babeljs.io/) 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。\n\n安装：\n\n```shell\nnpm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n配置：\n```javascript\n// webpack.config.js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']  // 使用@babel/preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel/preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。\n\n\n### 2.2 css-loader style-loader\n\ncss-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;\nstyle-loader 的作用是将 CSS 样式以 ``<style>`` 标签的形式插入到 HTML 页面中。\n\n安装：\n```shell\nnpm install css-loader style-loader -D\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader' // 将CSS文件转换为JavaScript模块\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.3 sass-loader less-loader\n\nsass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。\n\n- sass-loader \n\n安装：\n\n```shell\nnpm install sass-loader dart-sass --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.scss$/, // 匹配以.scss结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'sass-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n- less-loader\n\n安装：\n\n```shell\nnpm install less-loader less --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.less/, // 匹配以.less结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.4 postcss-loader\n\npostcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。[``PostCSS``](https://www.postcss.com.cn/) 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。\n\n安装：\n\n```shell\nnpm install postcss-loader postcss autoprefixer cssnano --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader', // 将CSS文件转换为JavaScript模块\n          'postcss-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n\n```javascript\n// postcss.config.js\nmodule.exports = {\n  plugins: [\n    require('autoprefixer'),\n    require('cssnano')\n  ]\n};\n```\n\n### 2.4 file-loader url-loader \n\nfile-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：\n\n``file-loader:``\n\n- 将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。\n- 适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。\n- 返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。\n\n``url-loader:``\n\n- 将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，\n则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。\n\n:::warning\nWebpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader\n:::\n\n[资源模块](https://webpack.docschina.org/guides/asset-modules/#root)\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.png/,\n        type: 'asset/resource'\n      }\n    ]\n  }\n};\n```\n\n\n### 2.5 thread-loader\n\nthread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。\n\n安装：\n\n```shell\nnpm install thread-loader --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n","slug":"webpack/loader","published":1,"updated":"2023-07-03T10:22:50.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xhz0005322zbms77p6a","content":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<span id=\"more\"></span>\n\n<h2 id=\"1-什么是-Loader\"><a href=\"#1-什么是-Loader\" class=\"headerlink\" title=\"1. 什么是 Loader ?\"></a>1. 什么是 Loader ?</h2><p>Loader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。<br>Loader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。</p>\n<h2 id=\"2-常用-loader-及其配置应用\"><a href=\"#2-常用-loader-及其配置应用\" class=\"headerlink\" title=\"2. 常用 loader 及其配置应用\"></a>2. 常用 loader 及其配置应用</h2><h3 id=\"2-1-babel-loader\"><a href=\"#2-1-babel-loader\" class=\"headerlink\" title=\"2.1 babel-loader\"></a>2.1 babel-loader</h3><p>babel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 <a href=\"https://babeljs.io/\"><code>Babel</code></a> 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install --save-dev babel-loader @babel&#x2F;core @babel&#x2F;preset-env</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; webpack.config.js\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F;...\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: &#123;\n          loader: &#39;babel-loader&#39;,\n          options: &#123;\n            presets: [&#39;@babel&#x2F;preset-env&#39;]  &#x2F;&#x2F; 使用@babel&#x2F;preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel&#x2F;preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          &#125;\n        &#125;\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n\n<p>配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。</p>\n<h3 id=\"2-2-css-loader-style-loader\"><a href=\"#2-2-css-loader-style-loader\" class=\"headerlink\" title=\"2.2 css-loader style-loader\"></a>2.2 css-loader style-loader</h3><p>css-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;<br>style-loader 的作用是将 CSS 样式以 <code>&lt;style&gt;</code> 标签的形式插入到 HTML 页面中。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install css-loader style-loader -D</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39; &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-3-sass-loader-less-loader\"><a href=\"#2-3-sass-loader-less-loader\" class=\"headerlink\" title=\"2.3 sass-loader less-loader\"></a>2.3 sass-loader less-loader</h3><p>sass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。</p>\n<ul>\n<li>sass-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install sass-loader dart-sass --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.scss$&#x2F;, &#x2F;&#x2F; 匹配以.scss结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;sass-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>less-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install less-loader less --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.less&#x2F;, &#x2F;&#x2F; 匹配以.less结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;less-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-4-postcss-loader\"><a href=\"#2-4-postcss-loader\" class=\"headerlink\" title=\"2.4 postcss-loader\"></a>2.4 postcss-loader</h3><p>postcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。<a href=\"https://www.postcss.com.cn/\"><code>PostCSS</code></a> 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install postcss-loader postcss autoprefixer cssnano --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39;, &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n          &#39;postcss-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; postcss.config.js\nmodule.exports &#x3D; &#123;\n  plugins: [\n    require(&#39;autoprefixer&#39;),\n    require(&#39;cssnano&#39;)\n  ]\n&#125;;</code></pre>\n\n<h3 id=\"2-4-file-loader-url-loader\"><a href=\"#2-4-file-loader-url-loader\" class=\"headerlink\" title=\"2.4 file-loader url-loader\"></a>2.4 file-loader url-loader</h3><p>file-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：</p>\n<p><code>file-loader:</code></p>\n<ul>\n<li>将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。</li>\n<li>适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。</li>\n<li>返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。</li>\n</ul>\n<p><code>url-loader:</code></p>\n<ul>\n<li>将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，<br>则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>Webpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader</p>\n</div>\n<p><a href=\"https://webpack.docschina.org/guides/asset-modules/#root\">资源模块</a></p>\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.png&#x2F;,\n        type: &#39;asset&#x2F;resource&#39;\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n\n<h3 id=\"2-5-thread-loader\"><a href=\"#2-5-thread-loader\" class=\"headerlink\" title=\"2.5 thread-loader\"></a>2.5 thread-loader</h3><p>thread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install thread-loader --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: [\n          &#39;thread-loader&#39;,\n          &#39;babel-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n","site":{"data":{}},"excerpt":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->","more":"<h2 id=\"1-什么是-Loader\"><a href=\"#1-什么是-Loader\" class=\"headerlink\" title=\"1. 什么是 Loader ?\"></a>1. 什么是 Loader ?</h2><p>Loader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。<br>Loader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。</p>\n<h2 id=\"2-常用-loader-及其配置应用\"><a href=\"#2-常用-loader-及其配置应用\" class=\"headerlink\" title=\"2. 常用 loader 及其配置应用\"></a>2. 常用 loader 及其配置应用</h2><h3 id=\"2-1-babel-loader\"><a href=\"#2-1-babel-loader\" class=\"headerlink\" title=\"2.1 babel-loader\"></a>2.1 babel-loader</h3><p>babel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 <a href=\"https://babeljs.io/\"><code>Babel</code></a> 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install --save-dev babel-loader @babel&#x2F;core @babel&#x2F;preset-env</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; webpack.config.js\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F;...\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: &#123;\n          loader: &#39;babel-loader&#39;,\n          options: &#123;\n            presets: [&#39;@babel&#x2F;preset-env&#39;]  &#x2F;&#x2F; 使用@babel&#x2F;preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel&#x2F;preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          &#125;\n        &#125;\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n\n<p>配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。</p>\n<h3 id=\"2-2-css-loader-style-loader\"><a href=\"#2-2-css-loader-style-loader\" class=\"headerlink\" title=\"2.2 css-loader style-loader\"></a>2.2 css-loader style-loader</h3><p>css-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;<br>style-loader 的作用是将 CSS 样式以 <code>&lt;style&gt;</code> 标签的形式插入到 HTML 页面中。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install css-loader style-loader -D</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39; &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-3-sass-loader-less-loader\"><a href=\"#2-3-sass-loader-less-loader\" class=\"headerlink\" title=\"2.3 sass-loader less-loader\"></a>2.3 sass-loader less-loader</h3><p>sass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。</p>\n<ul>\n<li>sass-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install sass-loader dart-sass --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.scss$&#x2F;, &#x2F;&#x2F; 匹配以.scss结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;sass-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>less-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install less-loader less --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.less&#x2F;, &#x2F;&#x2F; 匹配以.less结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;less-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-4-postcss-loader\"><a href=\"#2-4-postcss-loader\" class=\"headerlink\" title=\"2.4 postcss-loader\"></a>2.4 postcss-loader</h3><p>postcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。<a href=\"https://www.postcss.com.cn/\"><code>PostCSS</code></a> 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install postcss-loader postcss autoprefixer cssnano --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39;, &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n          &#39;postcss-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; postcss.config.js\nmodule.exports &#x3D; &#123;\n  plugins: [\n    require(&#39;autoprefixer&#39;),\n    require(&#39;cssnano&#39;)\n  ]\n&#125;;</code></pre>\n\n<h3 id=\"2-4-file-loader-url-loader\"><a href=\"#2-4-file-loader-url-loader\" class=\"headerlink\" title=\"2.4 file-loader url-loader\"></a>2.4 file-loader url-loader</h3><p>file-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：</p>\n<p><code>file-loader:</code></p>\n<ul>\n<li>将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。</li>\n<li>适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。</li>\n<li>返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。</li>\n</ul>\n<p><code>url-loader:</code></p>\n<ul>\n<li>将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，<br>则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。</li>\n</ul>\n<p>:::warning<br>Webpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader<br>:::</p>\n<p><a href=\"https://webpack.docschina.org/guides/asset-modules/#root\">资源模块</a></p>\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.png&#x2F;,\n        type: &#39;asset&#x2F;resource&#39;\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n\n<h3 id=\"2-5-thread-loader\"><a href=\"#2-5-thread-loader\" class=\"headerlink\" title=\"2.5 thread-loader\"></a>2.5 thread-loader</h3><p>thread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install thread-loader --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: [\n          &#39;thread-loader&#39;,\n          &#39;babel-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>"},{"title":"Webpack Plugin的学习与使用","date":"2023-06-24T02:46:55.000Z","_content":"\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 plugin ?\n\nWebpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。\n\n## 2. Webpack 打包生命周期\n\nWebpack的打包生命周期可以分为以下几个阶段：\n\n1. 初始化阶段（Initialization）  \n\n - 解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置。\n - 实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 [``Tapable``](https://github.com/webpack/tapable) 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册。\n\n2. 编译阶段（Compilation）\n\n\n\n## 3. 常用 plugin 及其配置应用\n\n### 3.1 \n","source":"_posts/webpack/plugin.md","raw":"---\ntitle: Webpack Plugin的学习与使用\ndate: 2023-06-24 10:46:55\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 plugin ?\n\nWebpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。\n\n## 2. Webpack 打包生命周期\n\nWebpack的打包生命周期可以分为以下几个阶段：\n\n1. 初始化阶段（Initialization）  \n\n - 解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置。\n - 实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 [``Tapable``](https://github.com/webpack/tapable) 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册。\n\n2. 编译阶段（Compilation）\n\n\n\n## 3. 常用 plugin 及其配置应用\n\n### 3.1 \n","slug":"webpack/plugin","published":1,"updated":"2023-07-04T07:01:57.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xi00006322z7kpc7w7y","content":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<span id=\"more\"></span>\n\n<h2 id=\"1-什么是-plugin\"><a href=\"#1-什么是-plugin\" class=\"headerlink\" title=\"1. 什么是 plugin ?\"></a>1. 什么是 plugin ?</h2><p>Webpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。</p>\n<h2 id=\"2-Webpack-打包生命周期\"><a href=\"#2-Webpack-打包生命周期\" class=\"headerlink\" title=\"2. Webpack 打包生命周期\"></a>2. Webpack 打包生命周期</h2><p>Webpack的打包生命周期可以分为以下几个阶段：</p>\n<ol>\n<li>初始化阶段（Initialization）</li>\n</ol>\n<ul>\n<li>解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置。</li>\n<li>实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 <a href=\"https://github.com/webpack/tapable\"><code>Tapable</code></a> 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册。</li>\n</ul>\n<ol start=\"2\">\n<li>编译阶段（Compilation）</li>\n</ol>\n<h2 id=\"3-常用-plugin-及其配置应用\"><a href=\"#3-常用-plugin-及其配置应用\" class=\"headerlink\" title=\"3. 常用 plugin 及其配置应用\"></a>3. 常用 plugin 及其配置应用</h2><h3 id=\"3-1\"><a href=\"#3-1\" class=\"headerlink\" title=\"3.1\"></a>3.1</h3>","site":{"data":{}},"excerpt":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->","more":"<h2 id=\"1-什么是-plugin\"><a href=\"#1-什么是-plugin\" class=\"headerlink\" title=\"1. 什么是 plugin ?\"></a>1. 什么是 plugin ?</h2><p>Webpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。</p>\n<h2 id=\"2-Webpack-打包生命周期\"><a href=\"#2-Webpack-打包生命周期\" class=\"headerlink\" title=\"2. Webpack 打包生命周期\"></a>2. Webpack 打包生命周期</h2><p>Webpack的打包生命周期可以分为以下几个阶段：</p>\n<ol>\n<li>初始化阶段（Initialization）</li>\n</ol>\n<ul>\n<li>解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置。</li>\n<li>实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 <a href=\"https://github.com/webpack/tapable\"><code>Tapable</code></a> 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册。</li>\n</ul>\n<ol start=\"2\">\n<li>编译阶段（Compilation）</li>\n</ol>\n<h2 id=\"3-常用-plugin-及其配置应用\"><a href=\"#3-常用-plugin-及其配置应用\" class=\"headerlink\" title=\"3. 常用 plugin 及其配置应用\"></a>3. 常用 plugin 及其配置应用</h2><h3 id=\"3-1\"><a href=\"#3-1\" class=\"headerlink\" title=\"3.1\"></a>3.1</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"cljo05xi00006322z7kpc7w7y","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi4000b322zbuqgaivt"},{"post_id":"cljo05xhs0001322z4u4r9qol","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi5000f322z8fp5g6ho"},{"post_id":"cljo05xhv0002322zdvtod7w8","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi5000g322z5odw4k2s"},{"post_id":"cljo05xhz0005322zbms77p6a","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi6000i322ze3y10wuw"}],"PostTag":[{"post_id":"cljo05xi00006322z7kpc7w7y","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi30009322zhntdbae9"},{"post_id":"cljo05xhs0001322z4u4r9qol","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi4000a322z1vbrdpkq"},{"post_id":"cljo05xhv0002322zdvtod7w8","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi5000e322z349mdslj"},{"post_id":"cljo05xhz0005322zbms77p6a","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi6000h322z0t6re9ey"}],"Tag":[{"name":"webpack","_id":"cljo05xhy0004322zgvrl21g4"}]}}