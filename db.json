{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/webpack-intro.png","path":"images/webpack-intro.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":0,"renderable":1},{"_id":"source/images/fastapi_create.png","path":"images/fastapi_create.png","modified":1,"renderable":0},{"_id":"source/images/fastapi_crud_docker_start.png","path":"images/fastapi_crud_docker_start.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"047ea9797c68539b6c6be2f690ea754d6a5a9c7c","modified":1689572797534},{"_id":"source/images/.DS_Store","hash":"e7a112f9f7a36cadca35892c04f1cb841cc5e5ac","modified":1689578342072},{"_id":"source/about/index.md","hash":"59a6637f28c77c073099f79d29287978c46d4954","modified":1688374768386},{"_id":"source/_posts/webpack/intro.md","hash":"bd416dfbec9585cdff0800b4622ffea7876b529d","modified":1688379758614},{"_id":"source/images/webpack-intro.png","hash":"47645d00bb74283fbbf7cbe3891a72e084c56990","modified":1686910776837},{"_id":"source/_posts/webpack/loader.md","hash":"2c8cfa092ecf485edfd19ec25e8d67ebf764a112","modified":1688379770323},{"_id":"source/_posts/webpack/loader-principle.md","hash":"330abb44703578d9a633d410bc7e87f9b071990c","modified":1688379790419},{"_id":"source/_posts/webpack/plugin.md","hash":"44bfd8168c433e148382c543d0ac487aac6bd134","modified":1688626114992},{"_id":"node_modules/hexo-theme-aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"1b312a6a2de107ba9dc952614f1078c78664a4e4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1688369607769},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1688369607769},{"_id":"source/_posts/_nestjs/intro.md","hash":"86bb43eba590237cb952856e0f83b2fe5c305a60","modified":1690268787912},{"_id":"source/_posts/_nestjs/overview.md","hash":"3bcd3768300a6c801dd5469792de5cde881786a0","modified":1690268793819},{"_id":"source/_posts/python/fastapi-intro.md","hash":"38f2d51699659fdf90b3d11bce1b86ce7dffad47","modified":1689561461613},{"_id":"source/images/fastapi_crud_docker_start.png","hash":"7f78cf1653ab8311f2634f6293cc04099f136cec","modified":1689572774873},{"_id":"source/_posts/sql/pg/common.md","hash":"88c607e66029b66ef418a37721008e0ba822d71a","modified":1690425783759},{"_id":"source/_posts/python/fastapi-crud.md","hash":"1d45e7f8aeea3ade6c5e6a7c9f24051ba77a8816","modified":1689659162412},{"_id":"source/_posts/nx/_intro.md","hash":"cf44e8a8fe2306cbba019db7a15db2ef1b520c3f","modified":1689045047869},{"_id":"source/images/fastapi_create.png","hash":"0f7d0c4f83c6c9e150b240e0590f785aba8320de","modified":1689564622660}],"Category":[{"name":"构建工具","_id":"cljo05xhx0003322z3yxv71pz"},{"name":"后端技术","_id":"clkkjvrer0002602zgg5oaqig"},{"name":"数据库","_id":"clkkjvrey0008602zhqrc6gsm"}],"Data":[],"Page":[{"title":"about","date":"2023-07-03T07:46:53.000Z","_content":"\n- hello about page","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-07-03 15:46:53\n---\n\n- hello about page","updated":"2023-07-03T08:59:28.386Z","path":"about/index.html","comments":1,"layout":"page","_id":"cljo05xhp0000322z0t8o6ivt","content":"<ul>\n<li>hello about page</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>hello about page</li>\n</ul>\n"}],"Post":[{"title":"Webpack Loader 实现原理","date":"2023-06-23T09:46:40.000Z","_content":"\n## 1. Loader是什么\n\n前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~\n\n## 2. Loader链式调用\n\n理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会``从右向左、从下到上``的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。\n\n## 3. Loader的实现方式\n\nWebpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。\n\n### 3.1 函数式 Loader\n\n这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。\n\n```javascript\nmodule.exports = function(source) {\n  const options = this.getOptions(); // loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  // 处理文件内容的逻辑\n  let transformSource = source\n  // 返回处理后的内容\n  return transformSource\n}\n```\n\n### 3.2 对象式Loader\n\n相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。\n\n```javascript\nmodule.exports = {\n  pitch: function(remainingRequest, precedingRequest, data) {\n    // pitch方法的处理逻辑\n    // 可以进行一些预处理或提前返回结果\n  },\n  loader: function(content, map, meta) {\n    // loader方法的处理逻辑\n    // 进行文件内容的转换和处理\n    // 返回处理后的内容\n    return transformedContent;\n  }\n}\n```\n\n### 3.3 在 Webpack 中如何使用自定义 Loader\n\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  resolveLoader: {\n    modules: ['node_modules', path.resolve(__dirname, 'loaders')], // loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          'your-loadername',\n        ]\n      }\n    ]\n  }\n};\n```\n\n## 4. 缓存和性能优化\n为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。\n","source":"_posts/webpack/loader-principle.md","raw":"---\ntitle: Webpack Loader 实现原理\ndate: 2023-06-23 17:46:40\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\n## 1. Loader是什么\n\n前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~\n\n## 2. Loader链式调用\n\n理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会``从右向左、从下到上``的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。\n\n## 3. Loader的实现方式\n\nWebpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。\n\n### 3.1 函数式 Loader\n\n这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。\n\n```javascript\nmodule.exports = function(source) {\n  const options = this.getOptions(); // loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  // 处理文件内容的逻辑\n  let transformSource = source\n  // 返回处理后的内容\n  return transformSource\n}\n```\n\n### 3.2 对象式Loader\n\n相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。\n\n```javascript\nmodule.exports = {\n  pitch: function(remainingRequest, precedingRequest, data) {\n    // pitch方法的处理逻辑\n    // 可以进行一些预处理或提前返回结果\n  },\n  loader: function(content, map, meta) {\n    // loader方法的处理逻辑\n    // 进行文件内容的转换和处理\n    // 返回处理后的内容\n    return transformedContent;\n  }\n}\n```\n\n### 3.3 在 Webpack 中如何使用自定义 Loader\n\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  resolveLoader: {\n    modules: ['node_modules', path.resolve(__dirname, 'loaders')], // loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          'your-loadername',\n        ]\n      }\n    ]\n  }\n};\n```\n\n## 4. 缓存和性能优化\n为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。\n","slug":"webpack/loader-principle","published":1,"updated":"2023-07-03T10:23:10.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xhs0001322z4u4r9qol","content":"<h2 id=\"1-Loader是什么\"><a href=\"#1-Loader是什么\" class=\"headerlink\" title=\"1. Loader是什么\"></a>1. Loader是什么</h2><p>前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~</p>\n<h2 id=\"2-Loader链式调用\"><a href=\"#2-Loader链式调用\" class=\"headerlink\" title=\"2. Loader链式调用\"></a>2. Loader链式调用</h2><p>理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会<code>从右向左、从下到上</code>的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。</p>\n<h2 id=\"3-Loader的实现方式\"><a href=\"#3-Loader的实现方式\" class=\"headerlink\" title=\"3. Loader的实现方式\"></a>3. Loader的实现方式</h2><p>Webpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。</p>\n<h3 id=\"3-1-函数式-Loader\"><a href=\"#3-1-函数式-Loader\" class=\"headerlink\" title=\"3.1 函数式 Loader\"></a>3.1 函数式 Loader</h3><p>这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; function(source) &#123;\n  const options &#x3D; this.getOptions(); &#x2F;&#x2F; loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  &#x2F;&#x2F; 处理文件内容的逻辑\n  let transformSource &#x3D; source\n  &#x2F;&#x2F; 返回处理后的内容\n  return transformSource\n&#125;</code></pre>\n\n<h3 id=\"3-2-对象式Loader\"><a href=\"#3-2-对象式Loader\" class=\"headerlink\" title=\"3.2 对象式Loader\"></a>3.2 对象式Loader</h3><p>相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  pitch: function(remainingRequest, precedingRequest, data) &#123;\n    &#x2F;&#x2F; pitch方法的处理逻辑\n    &#x2F;&#x2F; 可以进行一些预处理或提前返回结果\n  &#125;,\n  loader: function(content, map, meta) &#123;\n    &#x2F;&#x2F; loader方法的处理逻辑\n    &#x2F;&#x2F; 进行文件内容的转换和处理\n    &#x2F;&#x2F; 返回处理后的内容\n    return transformedContent;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-在-Webpack-中如何使用自定义-Loader\"><a href=\"#3-3-在-Webpack-中如何使用自定义-Loader\" class=\"headerlink\" title=\"3.3 在 Webpack 中如何使用自定义 Loader\"></a>3.3 在 Webpack 中如何使用自定义 Loader</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  resolveLoader: &#123;\n    modules: [&#39;node_modules&#39;, path.resolve(__dirname, &#39;loaders&#39;)], &#x2F;&#x2F; loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;,\n        use: [\n          &#39;your-loadername&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"4-缓存和性能优化\"><a href=\"#4-缓存和性能优化\" class=\"headerlink\" title=\"4. 缓存和性能优化\"></a>4. 缓存和性能优化</h2><p>为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Loader是什么\"><a href=\"#1-Loader是什么\" class=\"headerlink\" title=\"1. Loader是什么\"></a>1. Loader是什么</h2><p>前一篇介绍 Loader 的文章我们已经介绍过了，这边就不重复了~</p>\n<h2 id=\"2-Loader链式调用\"><a href=\"#2-Loader链式调用\" class=\"headerlink\" title=\"2. Loader链式调用\"></a>2. Loader链式调用</h2><p>理解 Loader 的加载顺序对于我们去了解其实现原理非常重要。Webpack 在解析模块的时候，根据文件的后缀名或规则匹配对应的 Loader ，并按照配置中的顺序依次应用。Webpack会<code>从右向左、从下到上</code>的顺序链式调用 Loader，当一个 Loader 执行时，它可以对文件内容进行处理并返回结果，然后 Webpack 将处理结果传递给下一个Loader作为它的输入， 下一个 Loader 继续对处理结果进行转换和处理，依此类推，直到 Loader 链的末尾，Loader链的最后一个 Loader 将返回最终处理后的内容，交给 Webpack 进行后续的模块解析和打包。</p>\n<h2 id=\"3-Loader的实现方式\"><a href=\"#3-Loader的实现方式\" class=\"headerlink\" title=\"3. Loader的实现方式\"></a>3. Loader的实现方式</h2><p>Webpack Loader的实现方式非常灵活，主要有两种方式：通过导出一个函数或通过导出一个Loader对象。</p>\n<h3 id=\"3-1-函数式-Loader\"><a href=\"#3-1-函数式-Loader\" class=\"headerlink\" title=\"3.1 函数式 Loader\"></a>3.1 函数式 Loader</h3><p>这种方式是最简单的 Loader 实现方式。Loader 函数接收源文件内容作为输入，通过对内容进行处理后，返回新的内容作为输出。我们可以在函数中使用各种工具、正则表达式、解析器等来处理文件内容。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; function(source) &#123;\n  const options &#x3D; this.getOptions(); &#x2F;&#x2F; loader context 是指在 loader 内使用 this 可以访问的一些方法或属性。\n  &#x2F;&#x2F; 处理文件内容的逻辑\n  let transformSource &#x3D; source\n  &#x2F;&#x2F; 返回处理后的内容\n  return transformSource\n&#125;</code></pre>\n\n<h3 id=\"3-2-对象式Loader\"><a href=\"#3-2-对象式Loader\" class=\"headerlink\" title=\"3.2 对象式Loader\"></a>3.2 对象式Loader</h3><p>相比于函数式 Loader，对象式 Loader 提供了更多的灵活性和可配置性。Loader 对象中必须包含一个 pitch 方法和一个 loader 方法。pitch 方法用于在文件被其他 Loader 处理之前，提前执行的逻辑。loader 方法是 Loader 的核心，用于进行文件内容的转换和处理。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  pitch: function(remainingRequest, precedingRequest, data) &#123;\n    &#x2F;&#x2F; pitch方法的处理逻辑\n    &#x2F;&#x2F; 可以进行一些预处理或提前返回结果\n  &#125;,\n  loader: function(content, map, meta) &#123;\n    &#x2F;&#x2F; loader方法的处理逻辑\n    &#x2F;&#x2F; 进行文件内容的转换和处理\n    &#x2F;&#x2F; 返回处理后的内容\n    return transformedContent;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-在-Webpack-中如何使用自定义-Loader\"><a href=\"#3-3-在-Webpack-中如何使用自定义-Loader\" class=\"headerlink\" title=\"3.3 在 Webpack 中如何使用自定义 Loader\"></a>3.3 在 Webpack 中如何使用自定义 Loader</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  resolveLoader: &#123;\n    modules: [&#39;node_modules&#39;, path.resolve(__dirname, &#39;loaders&#39;)], &#x2F;&#x2F; loaders 为当前项目根目录下存储 loaders 的文件夹，可自行定义\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;,\n        use: [\n          &#39;your-loadername&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"4-缓存和性能优化\"><a href=\"#4-缓存和性能优化\" class=\"headerlink\" title=\"4. 缓存和性能优化\"></a>4. 缓存和性能优化</h2><p>为了提高构建性能，Webpack 会对经过 Loader 处理的文件进行缓存。当文件内容没有发生变化时，Webpack 会直接使用缓存结果，避免重复处理。同时，Loader 也可以通过配置 cacheable 选项来指定是否支持缓存，以及通过设置 loader-runner 的 pitchExecuted 选项来控制是否执行pitch方法。</p>\n"},{"title":"Webpack 入门介绍","date":"2023-06-20T07:46:53.000Z","_content":"\nWebpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。\n\n<!-- more -->\n\n## 前言\n\n在过去的前端开发中，经常会使用的主要构建工具是 [``Gulp``](https://gulpjs.com/) 和 [``Grunt``](https://gruntjs.com/)。它们是基于任务（Stream / Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。\n\nGulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。\n\n然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。\n\nWebpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。\n\n## 1. 简介\n\nWebpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  \n\nWebpack 的主要优势包括：\n- ```模块化支持```：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。\n- ```强大的插件系统```：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。\n- ```开发环境支持```：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。\n- ```强大的生态系统```：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。\n\n![webpack-intro.png](/images/webpack-intro.png)\n\n## 2. 安装与使用\n\n### 2.1 安装\n\n接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，\n\n:::warning\n注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。\n:::\n  \n<br />\n\n```shell\n\nmkdir webpack-demo && cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D\n```\n\n```\n├── package.json\n├── package-lock.json\n└── src\n    └── index.js\n```\n\n然后我们更新一下 ``package.json`` ：\n\n```shell\n{\n  \"name\": \"webpack-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"  // 新增\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.87.0\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n}\n```\n接着我们在终端执行 ``npm run build``，webpack 会自动以 ``src`` 目录下的 ``index.js`` 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：\n\n```shell\n├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js\n```\n\n\n### 2.2 使用配置文件\n\n我们在项目下新建 ``webpack.config.js`` 文件来作为 webpack 的配置文件，然后同样执行 ``npm run build``\n\n```javascript\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.js', // 入口文件\n  output: {\n    filename: 'main.js', // bundle 文件名\n    path: path.resolve(__dirname, 'dist') // bundle 目录\n  }\n}\n```\n这一段基本配置，和我们在上一步中直接执行 ``npm run build`` 功能是一样的，都会在当前目录下生成一个 ``dist`` 目录及对应的打包出来的 bundle 文件。\n","source":"_posts/webpack/intro.md","raw":"---\ntitle: Webpack 入门介绍\ndate: 2023-06-20 15:46:53\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\nWebpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。\n\n<!-- more -->\n\n## 前言\n\n在过去的前端开发中，经常会使用的主要构建工具是 [``Gulp``](https://gulpjs.com/) 和 [``Grunt``](https://gruntjs.com/)。它们是基于任务（Stream / Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。\n\nGulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。\n\n然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。\n\nWebpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。\n\n## 1. 简介\n\nWebpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  \n\nWebpack 的主要优势包括：\n- ```模块化支持```：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。\n- ```强大的插件系统```：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。\n- ```开发环境支持```：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。\n- ```强大的生态系统```：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。\n\n![webpack-intro.png](/images/webpack-intro.png)\n\n## 2. 安装与使用\n\n### 2.1 安装\n\n接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，\n\n:::warning\n注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。\n:::\n  \n<br />\n\n```shell\n\nmkdir webpack-demo && cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D\n```\n\n```\n├── package.json\n├── package-lock.json\n└── src\n    └── index.js\n```\n\n然后我们更新一下 ``package.json`` ：\n\n```shell\n{\n  \"name\": \"webpack-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"  // 新增\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.87.0\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n}\n```\n接着我们在终端执行 ``npm run build``，webpack 会自动以 ``src`` 目录下的 ``index.js`` 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：\n\n```shell\n├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js\n```\n\n\n### 2.2 使用配置文件\n\n我们在项目下新建 ``webpack.config.js`` 文件来作为 webpack 的配置文件，然后同样执行 ``npm run build``\n\n```javascript\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.js', // 入口文件\n  output: {\n    filename: 'main.js', // bundle 文件名\n    path: path.resolve(__dirname, 'dist') // bundle 目录\n  }\n}\n```\n这一段基本配置，和我们在上一步中直接执行 ``npm run build`` 功能是一样的，都会在当前目录下生成一个 ``dist`` 目录及对应的打包出来的 bundle 文件。\n","slug":"webpack/intro","published":1,"updated":"2023-07-03T10:22:38.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xhv0002322zdvtod7w8","content":"<p>Webpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在过去的前端开发中，经常会使用的主要构建工具是 <a href=\"https://gulpjs.com/\"><code>Gulp</code></a> 和 <a href=\"https://gruntjs.com/\"><code>Grunt</code></a>。它们是基于任务（Stream &#x2F; Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。</p>\n<p>Gulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。</p>\n<p>然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。</p>\n<p>Webpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>Webpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  </p>\n<p>Webpack 的主要优势包括：</p>\n<ul>\n<li><code>模块化支持</code>：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。</li>\n<li><code>强大的插件系统</code>：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。</li>\n<li><code>开发环境支持</code>：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。</li>\n<li><code>强大的生态系统</code>：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。</li>\n</ul>\n<p><img src=\"/images/webpack-intro.png\" alt=\"webpack-intro.png\"></p>\n<h2 id=\"2-安装与使用\"><a href=\"#2-安装与使用\" class=\"headerlink\" title=\"2. 安装与使用\"></a>2. 安装与使用</h2><h3 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h3><p>接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。</p>\n</div>\n<br />\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\nmkdir webpack-demo &amp;&amp; cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">├── package.json\n├── package-lock.json\n└── src\n    └── index.js</code></pre>\n\n<p>然后我们更新一下 <code>package.json</code> ：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#123;\n  &quot;name&quot;: &quot;webpack-demo&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;  &#x2F;&#x2F; 新增\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;webpack&quot;: &quot;^5.87.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^5.1.4&quot;\n  &#125;\n&#125;</code></pre>\n<p>接着我们在终端执行 <code>npm run build</code>，webpack 会自动以 <code>src</code> 目录下的 <code>index.js</code> 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js</code></pre>\n\n\n<h3 id=\"2-2-使用配置文件\"><a href=\"#2-2-使用配置文件\" class=\"headerlink\" title=\"2.2 使用配置文件\"></a>2.2 使用配置文件</h3><p>我们在项目下新建 <code>webpack.config.js</code> 文件来作为 webpack 的配置文件，然后同样执行 <code>npm run build</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;)\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 入口文件\n  output: &#123;\n    filename: &#39;main.js&#39;, &#x2F;&#x2F; bundle 文件名\n    path: path.resolve(__dirname, &#39;dist&#39;) &#x2F;&#x2F; bundle 目录\n  &#125;\n&#125;</code></pre>\n<p>这一段基本配置，和我们在上一步中直接执行 <code>npm run build</code> 功能是一样的，都会在当前目录下生成一个 <code>dist</code> 目录及对应的打包出来的 bundle 文件。</p>\n","site":{"data":{}},"excerpt":"<p>Webpack是一个现代化的静态模块打包工具。它是一个用于构建前端项目的工具，通过分析项目中的各种资源（如JavaScript、CSS、图片等），将它们打包成最终的静态资源，以供浏览器加载和运行。</p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在过去的前端开发中，经常会使用的主要构建工具是 <a href=\"https://gulpjs.com/\"><code>Gulp</code></a> 和 <a href=\"https://gruntjs.com/\"><code>Grunt</code></a>。它们是基于任务（Stream &#x2F; Task）的构建工具，通过定义一系列任务来完成前端项目的构建和优化工作。这些任务可以包括文件合并、混淆、压缩、编译预处理器、静态资源处理等。</p>\n<p>Gulp 和 Grunt 在当时的前端开发中起到了很大的作用，简化了前端项目的构建流程，提高了开发效率。开发者可以通过编写任务配置文件，指定各个任务的执行顺序和所需的操作，然后通过命令行工具执行这些任务。</p>\n<p>然而，随着前端开发的快速发展和复杂化，Gulp 和 Grunt 的局限性逐渐凸显出来。它们的配置方式相对繁琐，需要编写大量的配置代码，而且配置文件的维护和管理也变得困难。在处理大型项目时，任务执行的效率也不够高，构建过程的速度较慢。</p>\n<p>Webpack 应运而生。Webpack 是一个现代化的静态模块打包工具，它引入了模块化的概念，并通过构建依赖图来管理模块之间的依赖关系。与 Gulp 和 Grunt 不同，Webpack 更加注重于模块的处理和构建过程的优化。</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>Webpack是一个模块打包工具，它可以将多个模块打包成最终的静态资源文件，如JavaScript、CSS、图片等。Webpack提供了丰富的功能和插件生态系统，可以进行模块化开发、代码分割、按需加载、资源优化等，使前端项目的构建过程更高效和可靠。  </p>\n<p>Webpack 的主要优势包括：</p>\n<ul>\n<li><code>模块化支持</code>：Webpack 支持各种模块化规范，如 CommonJS、ES modules、AMD 等，能够将项目拆分为模块，并按需加载，提高代码的可维护性和复用性。</li>\n<li><code>强大的插件系统</code>：Webpack 提供了强大的插件系统，使得开发者可以通过插件扩展和定制化构建过程。可以通过各种插件实现代码压缩、文件合并、资源优化等优化操作。</li>\n<li><code>开发环境支持</code>：Webpack 提供了开发环境下的热重载、模块热替换等功能，能够提高开发效率和调试体验。</li>\n<li><code>强大的生态系统</code>：Webpack 拥有庞大的社区和丰富的生态系统，有大量的插件和工具可供选择，能够满足各种项目需求。</li>\n</ul>\n<p><img src=\"/images/webpack-intro.png\" alt=\"webpack-intro.png\"></p>\n<h2 id=\"2-安装与使用\"><a href=\"#2-安装与使用\" class=\"headerlink\" title=\"2. 安装与使用\"></a>2. 安装与使用</h2><h3 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h3><p>接下来我们新建一个文件夹，然后在项目本地安装 webpack 及对应的 cli，</p>\n<p>:::warning<br>注：webpack 也可以全局安装，但一般不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中， 可能会导致构建失败。<br>:::</p>\n<br />\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\nmkdir webpack-demo &amp;&amp; cd webpack-demo \n\nnpm init -y\n\nnpm i webpack webpack-cli -D</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">├── package.json\n├── package-lock.json\n└── src\n    └── index.js</code></pre>\n\n<p>然后我们更新一下 <code>package.json</code> ：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#123;\n  &quot;name&quot;: &quot;webpack-demo&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;  &#x2F;&#x2F; 新增\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;webpack&quot;: &quot;^5.87.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^5.1.4&quot;\n  &#125;\n&#125;</code></pre>\n<p>接着我们在终端执行 <code>npm run build</code>，webpack 会自动以 <code>src</code> 目录下的 <code>index.js</code> 为入口进行打包，并将打包产物放置当前目录下的 dist 路径下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── dist\n│   └── main.js\n├── node_modules\n├── package.json\n├── package-lock.json\n└── src\n    └── main.js</code></pre>\n\n\n<h3 id=\"2-2-使用配置文件\"><a href=\"#2-2-使用配置文件\" class=\"headerlink\" title=\"2.2 使用配置文件\"></a>2.2 使用配置文件</h3><p>我们在项目下新建 <code>webpack.config.js</code> 文件来作为 webpack 的配置文件，然后同样执行 <code>npm run build</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;)\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 入口文件\n  output: &#123;\n    filename: &#39;main.js&#39;, &#x2F;&#x2F; bundle 文件名\n    path: path.resolve(__dirname, &#39;dist&#39;) &#x2F;&#x2F; bundle 目录\n  &#125;\n&#125;</code></pre>\n<p>这一段基本配置，和我们在上一步中直接执行 <code>npm run build</code> 功能是一样的，都会在当前目录下生成一个 <code>dist</code> 目录及对应的打包出来的 bundle 文件。</p>"},{"title":"Webpack Loader的学习与使用","date":"2023-06-22T02:46:55.000Z","_content":"\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 Loader ?\n\nLoader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。\nLoader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。\n\n## 2. 常用 loader 及其配置应用\n\n### 2.1 babel-loader\n\nbabel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 [``Babel``](https://babeljs.io/) 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。\n\n安装：\n\n```shell\nnpm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n配置：\n```javascript\n// webpack.config.js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']  // 使用@babel/preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel/preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。\n\n\n### 2.2 css-loader style-loader\n\ncss-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;\nstyle-loader 的作用是将 CSS 样式以 ``<style>`` 标签的形式插入到 HTML 页面中。\n\n安装：\n```shell\nnpm install css-loader style-loader -D\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader' // 将CSS文件转换为JavaScript模块\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.3 sass-loader less-loader\n\nsass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。\n\n- sass-loader \n\n安装：\n\n```shell\nnpm install sass-loader dart-sass --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.scss$/, // 匹配以.scss结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'sass-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n- less-loader\n\n安装：\n\n```shell\nnpm install less-loader less --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.less/, // 匹配以.less结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.4 postcss-loader\n\npostcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。[``PostCSS``](https://www.postcss.com.cn/) 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。\n\n安装：\n\n```shell\nnpm install postcss-loader postcss autoprefixer cssnano --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader', // 将CSS文件转换为JavaScript模块\n          'postcss-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n\n```javascript\n// postcss.config.js\nmodule.exports = {\n  plugins: [\n    require('autoprefixer'),\n    require('cssnano')\n  ]\n};\n```\n\n### 2.4 file-loader url-loader \n\nfile-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：\n\n``file-loader:``\n\n- 将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。\n- 适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。\n- 返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。\n\n``url-loader:``\n\n- 将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，\n则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。\n\n:::warning\nWebpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader\n:::\n\n[资源模块](https://webpack.docschina.org/guides/asset-modules/#root)\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.png/,\n        type: 'asset/resource'\n      }\n    ]\n  }\n};\n```\n\n\n### 2.5 thread-loader\n\nthread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。\n\n安装：\n\n```shell\nnpm install thread-loader --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n","source":"_posts/webpack/loader.md","raw":"---\ntitle: Webpack Loader的学习与使用\ndate: 2023-06-22 10:46:55\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 Loader ?\n\nLoader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。\nLoader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。\n\n## 2. 常用 loader 及其配置应用\n\n### 2.1 babel-loader\n\nbabel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 [``Babel``](https://babeljs.io/) 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。\n\n安装：\n\n```shell\nnpm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n配置：\n```javascript\n// webpack.config.js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']  // 使用@babel/preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel/preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。\n\n\n### 2.2 css-loader style-loader\n\ncss-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;\nstyle-loader 的作用是将 CSS 样式以 ``<style>`` 标签的形式插入到 HTML 页面中。\n\n安装：\n```shell\nnpm install css-loader style-loader -D\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader' // 将CSS文件转换为JavaScript模块\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.3 sass-loader less-loader\n\nsass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。\n\n- sass-loader \n\n安装：\n\n```shell\nnpm install sass-loader dart-sass --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.scss$/, // 匹配以.scss结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'sass-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n- less-loader\n\n安装：\n\n```shell\nnpm install less-loader less --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.less/, // 匹配以.less结尾的文件\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader',\n        ]\n      }\n    ]\n  }\n};\n```\n\n### 2.4 postcss-loader\n\npostcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。[``PostCSS``](https://www.postcss.com.cn/) 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。\n\n安装：\n\n```shell\nnpm install postcss-loader postcss autoprefixer cssnano --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 匹配以.css结尾的文件\n        use: [\n          'style-loader', // 将CSS样式注入到页面中的<style>标签\n          'css-loader', // 将CSS文件转换为JavaScript模块\n          'postcss-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n\n```javascript\n// postcss.config.js\nmodule.exports = {\n  plugins: [\n    require('autoprefixer'),\n    require('cssnano')\n  ]\n};\n```\n\n### 2.4 file-loader url-loader \n\nfile-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：\n\n``file-loader:``\n\n- 将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。\n- 适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。\n- 返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。\n\n``url-loader:``\n\n- 将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，\n则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。\n\n:::warning\nWebpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader\n:::\n\n[资源模块](https://webpack.docschina.org/guides/asset-modules/#root)\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.png/,\n        type: 'asset/resource'\n      }\n    ]\n  }\n};\n```\n\n\n### 2.5 thread-loader\n\nthread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。\n\n安装：\n\n```shell\nnpm install thread-loader --save-dev\n```\n\n配置：\n```javascript\nmodule.exports = {\n  // ...其他配置项\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 匹配以.js结尾的文件\n        exclude: /node_modules/, // 排除node_modules目录下的文件\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ]\n      }\n    ]\n  }\n};\n```\n","slug":"webpack/loader","published":1,"updated":"2023-07-03T10:22:50.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo05xhz0005322zbms77p6a","content":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<span id=\"more\"></span>\n\n<h2 id=\"1-什么是-Loader\"><a href=\"#1-什么是-Loader\" class=\"headerlink\" title=\"1. 什么是 Loader ?\"></a>1. 什么是 Loader ?</h2><p>Loader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。<br>Loader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。</p>\n<h2 id=\"2-常用-loader-及其配置应用\"><a href=\"#2-常用-loader-及其配置应用\" class=\"headerlink\" title=\"2. 常用 loader 及其配置应用\"></a>2. 常用 loader 及其配置应用</h2><h3 id=\"2-1-babel-loader\"><a href=\"#2-1-babel-loader\" class=\"headerlink\" title=\"2.1 babel-loader\"></a>2.1 babel-loader</h3><p>babel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 <a href=\"https://babeljs.io/\"><code>Babel</code></a> 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install --save-dev babel-loader @babel&#x2F;core @babel&#x2F;preset-env</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; webpack.config.js\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F;...\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: &#123;\n          loader: &#39;babel-loader&#39;,\n          options: &#123;\n            presets: [&#39;@babel&#x2F;preset-env&#39;]  &#x2F;&#x2F; 使用@babel&#x2F;preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel&#x2F;preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          &#125;\n        &#125;\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n\n<p>配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。</p>\n<h3 id=\"2-2-css-loader-style-loader\"><a href=\"#2-2-css-loader-style-loader\" class=\"headerlink\" title=\"2.2 css-loader style-loader\"></a>2.2 css-loader style-loader</h3><p>css-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;<br>style-loader 的作用是将 CSS 样式以 <code>&lt;style&gt;</code> 标签的形式插入到 HTML 页面中。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install css-loader style-loader -D</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39; &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-3-sass-loader-less-loader\"><a href=\"#2-3-sass-loader-less-loader\" class=\"headerlink\" title=\"2.3 sass-loader less-loader\"></a>2.3 sass-loader less-loader</h3><p>sass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。</p>\n<ul>\n<li>sass-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install sass-loader dart-sass --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.scss$&#x2F;, &#x2F;&#x2F; 匹配以.scss结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;sass-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>less-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install less-loader less --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.less&#x2F;, &#x2F;&#x2F; 匹配以.less结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;less-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-4-postcss-loader\"><a href=\"#2-4-postcss-loader\" class=\"headerlink\" title=\"2.4 postcss-loader\"></a>2.4 postcss-loader</h3><p>postcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。<a href=\"https://www.postcss.com.cn/\"><code>PostCSS</code></a> 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install postcss-loader postcss autoprefixer cssnano --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39;, &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n          &#39;postcss-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; postcss.config.js\nmodule.exports &#x3D; &#123;\n  plugins: [\n    require(&#39;autoprefixer&#39;),\n    require(&#39;cssnano&#39;)\n  ]\n&#125;;</code></pre>\n\n<h3 id=\"2-4-file-loader-url-loader\"><a href=\"#2-4-file-loader-url-loader\" class=\"headerlink\" title=\"2.4 file-loader url-loader\"></a>2.4 file-loader url-loader</h3><p>file-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：</p>\n<p><code>file-loader:</code></p>\n<ul>\n<li>将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。</li>\n<li>适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。</li>\n<li>返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。</li>\n</ul>\n<p><code>url-loader:</code></p>\n<ul>\n<li>将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，<br>则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>Webpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader</p>\n</div>\n<p><a href=\"https://webpack.docschina.org/guides/asset-modules/#root\">资源模块</a></p>\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.png&#x2F;,\n        type: &#39;asset&#x2F;resource&#39;\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n\n<h3 id=\"2-5-thread-loader\"><a href=\"#2-5-thread-loader\" class=\"headerlink\" title=\"2.5 thread-loader\"></a>2.5 thread-loader</h3><p>thread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install thread-loader --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: [\n          &#39;thread-loader&#39;,\n          &#39;babel-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n","site":{"data":{}},"excerpt":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->","more":"<h2 id=\"1-什么是-Loader\"><a href=\"#1-什么是-Loader\" class=\"headerlink\" title=\"1. 什么是 Loader ?\"></a>1. 什么是 Loader ?</h2><p>Loader Webpack 理解和处理的模块。例如，当遇到 JavaScript 文件时，可以使用 Babel Loader 将 ES6+ 的语法转换为兼容性更好的 ES5 语法；当遇到 CSS 文件时，可以使用 CSS Loader 将 CSS 文件转换为 JavaScript 对象，再使用 Style Loader 将其注入到页面中。<br>Loader 支持链式调用，我们可以在 Webpack 配置中按照一定的顺序定义多个 Loader，每个 Loader 都对模块进行一些特定的处理或转换，这种链式调用的方式让我们能够按需对模块进行处理，并且可以根据项目的需要进行灵活配置。</p>\n<h2 id=\"2-常用-loader-及其配置应用\"><a href=\"#2-常用-loader-及其配置应用\" class=\"headerlink\" title=\"2. 常用 loader 及其配置应用\"></a>2. 常用 loader 及其配置应用</h2><h3 id=\"2-1-babel-loader\"><a href=\"#2-1-babel-loader\" class=\"headerlink\" title=\"2.1 babel-loader\"></a>2.1 babel-loader</h3><p>babel-loader 是 Webpack 中用于将新版本的 JavaScript 代码（如ES6+）转换为旧版本（如ES5）的 Loader。它利用了 <a href=\"https://babeljs.io/\"><code>Babel</code></a> 这个流行的 JavaScript 编译器工具，使我们能够在旧版浏览器中运行使用了最新语法特性的 JavaScript 代码。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install --save-dev babel-loader @babel&#x2F;core @babel&#x2F;preset-env</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; webpack.config.js\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F;...\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: &#123;\n          loader: &#39;babel-loader&#39;,\n          options: &#123;\n            presets: [&#39;@babel&#x2F;preset-env&#39;]  &#x2F;&#x2F; 使用@babel&#x2F;preset-env预设，预设是一组Babel插件的集合，用于指定要使用的语法转换规则，通常使用的是@babel&#x2F;preset-env预设，它会根据目标浏览器的版本自动选择需要的插件进行转换\n          &#125;\n        &#125;\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n\n<p>配置完成后，Webpack 在构建过程中会使用 babel-loader 对所有匹配 test 条件的 JavaScript 文件进行转换。它会根据预设（Presets）的配置将新版本的 JavaScript 代码转换为目标浏览器支持的兼容性更好的代码，转换后的代码将被用于打包和部署。</p>\n<h3 id=\"2-2-css-loader-style-loader\"><a href=\"#2-2-css-loader-style-loader\" class=\"headerlink\" title=\"2.2 css-loader style-loader\"></a>2.2 css-loader style-loader</h3><p>css-loader 和 style-loader 是在 Webpack 中常用的一对 Loader 组合，它们通常会一起配合使用来处理CSS文件。css-loader 的作用是将 CSS 文件转换为 Webpack 可以理解和处理的模块，它负责解析CSS文件，并处理其中的 @import 和 url() 等引用关系，以及处理样式中的路径和依赖关系;<br>style-loader 的作用是将 CSS 样式以 <code>&lt;style&gt;</code> 标签的形式插入到 HTML 页面中。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install css-loader style-loader -D</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39; &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-3-sass-loader-less-loader\"><a href=\"#2-3-sass-loader-less-loader\" class=\"headerlink\" title=\"2.3 sass-loader less-loader\"></a>2.3 sass-loader less-loader</h3><p>sass-loader 和 less-loader是 Webpack 中用于处理 Sass 和 Less 等预处理器语言的Loader，它们的作用是将Sass和Less文件转换为CSS文件。</p>\n<ul>\n<li>sass-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install sass-loader dart-sass --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.scss$&#x2F;, &#x2F;&#x2F; 匹配以.scss结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;sass-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>less-loader</li>\n</ul>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install less-loader less --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.less&#x2F;, &#x2F;&#x2F; 匹配以.less结尾的文件\n        use: [\n          &#39;style-loader&#39;,\n          &#39;css-loader&#39;,\n          &#39;less-loader&#39;,\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"2-4-postcss-loader\"><a href=\"#2-4-postcss-loader\" class=\"headerlink\" title=\"2.4 postcss-loader\"></a>2.4 postcss-loader</h3><p>postcss-loader 的作用是为 CSS 样式添加自动化的后处理过程。<a href=\"https://www.postcss.com.cn/\"><code>PostCSS</code></a> 是一个功能强大的 CSS 处理工具，它使用插件机制来处理 CSS，并提供了许多有用的功能，如自动添加浏览器前缀、通过 preset 来转换最新的 CSS语法等，还可以通过使用插件来优化和压缩 CSS 代码，以减少文件大小和提升性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install postcss-loader postcss autoprefixer cssnano --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 匹配以.css结尾的文件\n        use: [\n          &#39;style-loader&#39;, &#x2F;&#x2F; 将CSS样式注入到页面中的&lt;style&gt;标签\n          &#39;css-loader&#39;, &#x2F;&#x2F; 将CSS文件转换为JavaScript模块\n          &#39;postcss-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; postcss.config.js\nmodule.exports &#x3D; &#123;\n  plugins: [\n    require(&#39;autoprefixer&#39;),\n    require(&#39;cssnano&#39;)\n  ]\n&#125;;</code></pre>\n\n<h3 id=\"2-4-file-loader-url-loader\"><a href=\"#2-4-file-loader-url-loader\" class=\"headerlink\" title=\"2.4 file-loader url-loader\"></a>2.4 file-loader url-loader</h3><p>file-loader 和 url-loader 都是 Webpack 中用于处理文件资源的 Loader，它们的作用是将文件复制到输出目录，并返回文件的引用路径用于在项目中使用，但它们有一点点区别：</p>\n<p><code>file-loader:</code></p>\n<ul>\n<li>将文件复制到输出目录：file-loader 会将文件复制到 Webpack 输出目录中（一般都是dist目录），并返回文件的引用路径，这样我们就可以在项目中通过该引用路径来访问相应的文件。</li>\n<li>适用于任何文件类型：file-loader 适用于任何类型的文件，包括图片、字体、音视频文件等。它不仅可以处理文件的复制和路径处理，还可以在处理过程中根据配置对文件进行重命名、指定输出路径等操作。</li>\n<li>返回文件的引用路径：file-loader 返回文件在输出目录中的相对路径或绝对路径，具体取决于配置。你可以使用该路径来在 HTML、CSS 或 JavaScript 来引用相应的文件。</li>\n</ul>\n<p><code>url-loader:</code></p>\n<ul>\n<li>将文件转换为 Data URL：与 file-loader 不同，url-loader 可以将文件转换为Data URL格式，将文件内容嵌入到生成的文件中，以 limit 配置为限，小于 limit 体积的文件可以直接以Data URL的形式存在，而不需要生成额外的文件，以此来达到减少 http 请求的优化，大于 limit 的话，<br>则会使用备用选项来指定的其他 Loader（通常是file-loader）来处理文件。</li>\n</ul>\n<p>:::warning<br>Webpack5 已经使用资源模块(asset module)来替代上面两个 Loader ，这是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 Loader<br>:::</p>\n<p><a href=\"https://webpack.docschina.org/guides/asset-modules/#root\">资源模块</a></p>\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.png&#x2F;,\n        type: &#39;asset&#x2F;resource&#39;\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>\n\n\n<h3 id=\"2-5-thread-loader\"><a href=\"#2-5-thread-loader\" class=\"headerlink\" title=\"2.5 thread-loader\"></a>2.5 thread-loader</h3><p>thread-loader 的作用是将耗时的 Loader，比如 babel-loader 操作转移到单独的 worker 线程中执行，以提高整体的构建性能。</p>\n<p>安装：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install thread-loader --save-dev</code></pre>\n\n<p>配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置项\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 匹配以.js结尾的文件\n        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 排除node_modules目录下的文件\n        use: [\n          &#39;thread-loader&#39;,\n          &#39;babel-loader&#39;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;</code></pre>"},{"title":"Webpack Plugin的学习与使用","date":"2023-06-24T02:46:55.000Z","_content":"\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 plugin ?\n\nWebpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。\n\n## 2. Webpack 打包生命周期\n\nWebpack的打包生命周期可以分为以下几个阶段：\n\n``初始化阶段（Initialization）  ``\n\n  - 解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置；\n  - 实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 [``Tapable``](https://github.com/webpack/tapable) 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册；\n  \n\n``编译阶段（Compilation）``\n\n  - 编译模块：Webpack根据入口文件，递归地解析依赖关系，生成模块；\n  - 执行Loader：对模块应用配置中定义的Loader进行转换和处理；\n  - 构建依赖图：根据模块的依赖关系构建依赖图，确定模块之间的依赖关系；\n\n``完成编译阶段（Seal Compilation）``\n\n  - 生成编译结果：将所有模块转换后的结果和依赖图整合，生成编译结果；\n  - 触发额外的编译操作：根据需要，可能触发额外的编译操作，如热模块替换（HMR）；\n\n``输出阶段（Output）``\n\n  - 输出文件：将编译结果输出到指定的输出目录，生成最终的静态资源文件；\n\n  在每个阶段，Webpack 会触发一系列的事件（Hooks），插件可以监听这些事件并执行相应的逻辑。常见的Webpack生命周期事件包括：\n\n  - beforeRun/beforeCompile：在编译开始前触发；\n  - compile：编译开始时触发；\n  - thisCompilation：在每次新的编译创建时触发；\n  - compilation：在每次编译创建完成后触发；\n  - done：整个编译过程完成时触发；\n\n  所有的 compiler 钩子可以在官网查看 [https://webpack.docschina.org/api/compiler-hooks/#afteremit](https://webpack.docschina.org/api/compiler-hooks/#afteremit)\n\n## 3. 常用 plugin 及其配置应用\n\n### 3.1 HtmlWebpackPlugin\n\n用于自动生成HTML文件，并将打包后的资源自动注入到HTML中。它简化了手动创建 HTML 文件的过程，同时提供了一些额外的功能，如压缩HTML、指定模板文件、自定义输出文件名等。\n\n\n### 3.2 MiniCssExtractPlugin\n\n用于将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载；\n\n### 3.3 CleanWebpackPlugin\n\n用于清理输出目录中的旧文件，确保每次构建都能生成新的输入目录；\n\n:::warning\n注：webpack5中已移除，使用 output 中的 clean 配置即可清除 dist 目录 \n:::\n\n```javascript\noutput: {\n  filename: 'bundle.js',\n  path: path.resolve(__dirname, 'dist'),\n  clean: true, // 在生成文件之前清空 output 目录\n},\n```\n\n### 3.4 DefinePlugin\n\n用于在编译时将你代码中的变量替换为环境变量，版本信息等配置信息；\n\n```javascript\nnew webpack.DefinePlugin({\n  PRODUCTION: JSON.stringify(true),\n  VERSION: JSON.stringify('1.0.0'),\n});\n```\n\n### 3.5 HotModuleReplacementPlugin\n\n用于启用热模块替换（Hot Module Replacement），热模块替换是一种开发时的特性，它允许在应用程序运行过程中，无需刷新整个页面，只替换发生变化的模块，以实现快速的代码更新和实时预览。\n\nHMR插件的实现原理如下：\n\n- 客户端连接：\n\n  HMR插件会在Webpack构建后生成一个运行时客户端，该客户端通过WebSocket与Webpack开发服务器建立连接；\n\n- 监听模块更新：\n\n  HMR插件会在Webpack编译阶段，将需要进行热替换的模块标记为可被接受更新的模块，插件会为这些模块添加监听，以便在模块发生变化时通知客户端；\n\n- 通知客户端：\n\n  当一个模块发生变化时，Webpack会通过WebSocket向运行时客户端发送更新通知，客户端接收到更新通知后，会向Webpack开发服务器发送Ajax请求，获取更新的模块代码；\n\n- 模块替换：\n\n  客户端在接收到新的模块代码后，会利用Webpack的模块热替换接口，将新的模块代码替换掉旧的模块，替换过程中，保留模块的状态（例如表单输入、组件的状态等），以便在替换完成后恢复到之前的状态；\n\n- 更新界面：\n\n  客户端在成功替换模块后，会通知应用程序的其他部分，以便更新界面和执行其他逻辑。","source":"_posts/webpack/plugin.md","raw":"---\ntitle: Webpack Plugin的学习与使用\ndate: 2023-06-24 10:46:55\ntags: \n  webpack\ncategories:\n  构建工具\n---\n\n<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<!-- more -->\n\n## 1. 什么是 plugin ?\n\nWebpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。\n\n## 2. Webpack 打包生命周期\n\nWebpack的打包生命周期可以分为以下几个阶段：\n\n``初始化阶段（Initialization）  ``\n\n  - 解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置；\n  - 实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 [``Tapable``](https://github.com/webpack/tapable) 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册；\n  \n\n``编译阶段（Compilation）``\n\n  - 编译模块：Webpack根据入口文件，递归地解析依赖关系，生成模块；\n  - 执行Loader：对模块应用配置中定义的Loader进行转换和处理；\n  - 构建依赖图：根据模块的依赖关系构建依赖图，确定模块之间的依赖关系；\n\n``完成编译阶段（Seal Compilation）``\n\n  - 生成编译结果：将所有模块转换后的结果和依赖图整合，生成编译结果；\n  - 触发额外的编译操作：根据需要，可能触发额外的编译操作，如热模块替换（HMR）；\n\n``输出阶段（Output）``\n\n  - 输出文件：将编译结果输出到指定的输出目录，生成最终的静态资源文件；\n\n  在每个阶段，Webpack 会触发一系列的事件（Hooks），插件可以监听这些事件并执行相应的逻辑。常见的Webpack生命周期事件包括：\n\n  - beforeRun/beforeCompile：在编译开始前触发；\n  - compile：编译开始时触发；\n  - thisCompilation：在每次新的编译创建时触发；\n  - compilation：在每次编译创建完成后触发；\n  - done：整个编译过程完成时触发；\n\n  所有的 compiler 钩子可以在官网查看 [https://webpack.docschina.org/api/compiler-hooks/#afteremit](https://webpack.docschina.org/api/compiler-hooks/#afteremit)\n\n## 3. 常用 plugin 及其配置应用\n\n### 3.1 HtmlWebpackPlugin\n\n用于自动生成HTML文件，并将打包后的资源自动注入到HTML中。它简化了手动创建 HTML 文件的过程，同时提供了一些额外的功能，如压缩HTML、指定模板文件、自定义输出文件名等。\n\n\n### 3.2 MiniCssExtractPlugin\n\n用于将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载；\n\n### 3.3 CleanWebpackPlugin\n\n用于清理输出目录中的旧文件，确保每次构建都能生成新的输入目录；\n\n:::warning\n注：webpack5中已移除，使用 output 中的 clean 配置即可清除 dist 目录 \n:::\n\n```javascript\noutput: {\n  filename: 'bundle.js',\n  path: path.resolve(__dirname, 'dist'),\n  clean: true, // 在生成文件之前清空 output 目录\n},\n```\n\n### 3.4 DefinePlugin\n\n用于在编译时将你代码中的变量替换为环境变量，版本信息等配置信息；\n\n```javascript\nnew webpack.DefinePlugin({\n  PRODUCTION: JSON.stringify(true),\n  VERSION: JSON.stringify('1.0.0'),\n});\n```\n\n### 3.5 HotModuleReplacementPlugin\n\n用于启用热模块替换（Hot Module Replacement），热模块替换是一种开发时的特性，它允许在应用程序运行过程中，无需刷新整个页面，只替换发生变化的模块，以实现快速的代码更新和实时预览。\n\nHMR插件的实现原理如下：\n\n- 客户端连接：\n\n  HMR插件会在Webpack构建后生成一个运行时客户端，该客户端通过WebSocket与Webpack开发服务器建立连接；\n\n- 监听模块更新：\n\n  HMR插件会在Webpack编译阶段，将需要进行热替换的模块标记为可被接受更新的模块，插件会为这些模块添加监听，以便在模块发生变化时通知客户端；\n\n- 通知客户端：\n\n  当一个模块发生变化时，Webpack会通过WebSocket向运行时客户端发送更新通知，客户端接收到更新通知后，会向Webpack开发服务器发送Ajax请求，获取更新的模块代码；\n\n- 模块替换：\n\n  客户端在接收到新的模块代码后，会利用Webpack的模块热替换接口，将新的模块代码替换掉旧的模块，替换过程中，保留模块的状态（例如表单输入、组件的状态等），以便在替换完成后恢复到之前的状态；\n\n- 更新界面：\n\n  客户端在成功替换模块后，会通知应用程序的其他部分，以便更新界面和执行其他逻辑。","slug":"webpack/plugin","published":1,"updated":"2023-07-06T06:48:34.992Z","_id":"cljo05xi00006322z7kpc7w7y","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->\n\n<span id=\"more\"></span>\n\n<h2 id=\"1-什么是-plugin\"><a href=\"#1-什么是-plugin\" class=\"headerlink\" title=\"1. 什么是 plugin ?\"></a>1. 什么是 plugin ?</h2><p>Webpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。</p>\n<h2 id=\"2-Webpack-打包生命周期\"><a href=\"#2-Webpack-打包生命周期\" class=\"headerlink\" title=\"2. Webpack 打包生命周期\"></a>2. Webpack 打包生命周期</h2><p>Webpack的打包生命周期可以分为以下几个阶段：</p>\n<p><code>初始化阶段（Initialization）  </code></p>\n<ul>\n<li>解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置；</li>\n<li>实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 <a href=\"https://github.com/webpack/tapable\"><code>Tapable</code></a> 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册；</li>\n</ul>\n<p><code>编译阶段（Compilation）</code></p>\n<ul>\n<li>编译模块：Webpack根据入口文件，递归地解析依赖关系，生成模块；</li>\n<li>执行Loader：对模块应用配置中定义的Loader进行转换和处理；</li>\n<li>构建依赖图：根据模块的依赖关系构建依赖图，确定模块之间的依赖关系；</li>\n</ul>\n<p><code>完成编译阶段（Seal Compilation）</code></p>\n<ul>\n<li>生成编译结果：将所有模块转换后的结果和依赖图整合，生成编译结果；</li>\n<li>触发额外的编译操作：根据需要，可能触发额外的编译操作，如热模块替换（HMR）；</li>\n</ul>\n<p><code>输出阶段（Output）</code></p>\n<ul>\n<li>输出文件：将编译结果输出到指定的输出目录，生成最终的静态资源文件；</li>\n</ul>\n<p>  在每个阶段，Webpack 会触发一系列的事件（Hooks），插件可以监听这些事件并执行相应的逻辑。常见的Webpack生命周期事件包括：</p>\n<ul>\n<li>beforeRun&#x2F;beforeCompile：在编译开始前触发；</li>\n<li>compile：编译开始时触发；</li>\n<li>thisCompilation：在每次新的编译创建时触发；</li>\n<li>compilation：在每次编译创建完成后触发；</li>\n<li>done：整个编译过程完成时触发；</li>\n</ul>\n<p>  所有的 compiler 钩子可以在官网查看 <a href=\"https://webpack.docschina.org/api/compiler-hooks/#afteremit\">https://webpack.docschina.org/api/compiler-hooks/#afteremit</a></p>\n<h2 id=\"3-常用-plugin-及其配置应用\"><a href=\"#3-常用-plugin-及其配置应用\" class=\"headerlink\" title=\"3. 常用 plugin 及其配置应用\"></a>3. 常用 plugin 及其配置应用</h2><h3 id=\"3-1-HtmlWebpackPlugin\"><a href=\"#3-1-HtmlWebpackPlugin\" class=\"headerlink\" title=\"3.1 HtmlWebpackPlugin\"></a>3.1 HtmlWebpackPlugin</h3><p>用于自动生成HTML文件，并将打包后的资源自动注入到HTML中。它简化了手动创建 HTML 文件的过程，同时提供了一些额外的功能，如压缩HTML、指定模板文件、自定义输出文件名等。</p>\n<h3 id=\"3-2-MiniCssExtractPlugin\"><a href=\"#3-2-MiniCssExtractPlugin\" class=\"headerlink\" title=\"3.2 MiniCssExtractPlugin\"></a>3.2 MiniCssExtractPlugin</h3><p>用于将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载；</p>\n<h3 id=\"3-3-CleanWebpackPlugin\"><a href=\"#3-3-CleanWebpackPlugin\" class=\"headerlink\" title=\"3.3 CleanWebpackPlugin\"></a>3.3 CleanWebpackPlugin</h3><p>用于清理输出目录中的旧文件，确保每次构建都能生成新的输入目录；</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注：webpack5中已移除，使用 output 中的 clean 配置即可清除 dist 目录</p>\n</div>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">output: &#123;\n  filename: &#39;bundle.js&#39;,\n  path: path.resolve(__dirname, &#39;dist&#39;),\n  clean: true, &#x2F;&#x2F; 在生成文件之前清空 output 目录\n&#125;,</code></pre>\n\n<h3 id=\"3-4-DefinePlugin\"><a href=\"#3-4-DefinePlugin\" class=\"headerlink\" title=\"3.4 DefinePlugin\"></a>3.4 DefinePlugin</h3><p>用于在编译时将你代码中的变量替换为环境变量，版本信息等配置信息；</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">new webpack.DefinePlugin(&#123;\n  PRODUCTION: JSON.stringify(true),\n  VERSION: JSON.stringify(&#39;1.0.0&#39;),\n&#125;);</code></pre>\n\n<h3 id=\"3-5-HotModuleReplacementPlugin\"><a href=\"#3-5-HotModuleReplacementPlugin\" class=\"headerlink\" title=\"3.5 HotModuleReplacementPlugin\"></a>3.5 HotModuleReplacementPlugin</h3><p>用于启用热模块替换（Hot Module Replacement），热模块替换是一种开发时的特性，它允许在应用程序运行过程中，无需刷新整个页面，只替换发生变化的模块，以实现快速的代码更新和实时预览。</p>\n<p>HMR插件的实现原理如下：</p>\n<ul>\n<li><p>客户端连接：</p>\n<p>HMR插件会在Webpack构建后生成一个运行时客户端，该客户端通过WebSocket与Webpack开发服务器建立连接；</p>\n</li>\n<li><p>监听模块更新：</p>\n<p>HMR插件会在Webpack编译阶段，将需要进行热替换的模块标记为可被接受更新的模块，插件会为这些模块添加监听，以便在模块发生变化时通知客户端；</p>\n</li>\n<li><p>通知客户端：</p>\n<p>当一个模块发生变化时，Webpack会通过WebSocket向运行时客户端发送更新通知，客户端接收到更新通知后，会向Webpack开发服务器发送Ajax请求，获取更新的模块代码；</p>\n</li>\n<li><p>模块替换：</p>\n<p>客户端在接收到新的模块代码后，会利用Webpack的模块热替换接口，将新的模块代码替换掉旧的模块，替换过程中，保留模块的状态（例如表单输入、组件的状态等），以便在替换完成后恢复到之前的状态；</p>\n</li>\n<li><p>更新界面：</p>\n<p>客户端在成功替换模块后，会通知应用程序的其他部分，以便更新界面和执行其他逻辑。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<!-- Webpack Loader是Webpack的一个重要概念，它用于对模块的源代码进行转换和处理。在Webpack的构建过程中，Loader负责将不同类型的文件转换为可以被Webpack理解和处理的模块。 -->","more":"<h2 id=\"1-什么是-plugin\"><a href=\"#1-什么是-plugin\" class=\"headerlink\" title=\"1. 什么是 plugin ?\"></a>1. 什么是 plugin ?</h2><p>Webpack 插件是用于扩展和定制 Webpack 功能的 JavaScript 模块。它们与 Webpack 的构建过程密切相关，可以在不同的构建阶段执行特定的任务，例如优化代码、生成文件、处理资源等。</p>\n<h2 id=\"2-Webpack-打包生命周期\"><a href=\"#2-Webpack-打包生命周期\" class=\"headerlink\" title=\"2. Webpack 打包生命周期\"></a>2. Webpack 打包生命周期</h2><p>Webpack的打包生命周期可以分为以下几个阶段：</p>\n<p><code>初始化阶段（Initialization）  </code></p>\n<ul>\n<li>解析配置文件：Webpack读取并解析配置文件，确定构建的入口、输出等配置；</li>\n<li>实例化Compiler：Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。它扩展（extends）自 <a href=\"https://github.com/webpack/tapable\"><code>Tapable</code></a> 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册；</li>\n</ul>\n<p><code>编译阶段（Compilation）</code></p>\n<ul>\n<li>编译模块：Webpack根据入口文件，递归地解析依赖关系，生成模块；</li>\n<li>执行Loader：对模块应用配置中定义的Loader进行转换和处理；</li>\n<li>构建依赖图：根据模块的依赖关系构建依赖图，确定模块之间的依赖关系；</li>\n</ul>\n<p><code>完成编译阶段（Seal Compilation）</code></p>\n<ul>\n<li>生成编译结果：将所有模块转换后的结果和依赖图整合，生成编译结果；</li>\n<li>触发额外的编译操作：根据需要，可能触发额外的编译操作，如热模块替换（HMR）；</li>\n</ul>\n<p><code>输出阶段（Output）</code></p>\n<ul>\n<li>输出文件：将编译结果输出到指定的输出目录，生成最终的静态资源文件；</li>\n</ul>\n<p>  在每个阶段，Webpack 会触发一系列的事件（Hooks），插件可以监听这些事件并执行相应的逻辑。常见的Webpack生命周期事件包括：</p>\n<ul>\n<li>beforeRun&#x2F;beforeCompile：在编译开始前触发；</li>\n<li>compile：编译开始时触发；</li>\n<li>thisCompilation：在每次新的编译创建时触发；</li>\n<li>compilation：在每次编译创建完成后触发；</li>\n<li>done：整个编译过程完成时触发；</li>\n</ul>\n<p>  所有的 compiler 钩子可以在官网查看 <a href=\"https://webpack.docschina.org/api/compiler-hooks/#afteremit\">https://webpack.docschina.org/api/compiler-hooks/#afteremit</a></p>\n<h2 id=\"3-常用-plugin-及其配置应用\"><a href=\"#3-常用-plugin-及其配置应用\" class=\"headerlink\" title=\"3. 常用 plugin 及其配置应用\"></a>3. 常用 plugin 及其配置应用</h2><h3 id=\"3-1-HtmlWebpackPlugin\"><a href=\"#3-1-HtmlWebpackPlugin\" class=\"headerlink\" title=\"3.1 HtmlWebpackPlugin\"></a>3.1 HtmlWebpackPlugin</h3><p>用于自动生成HTML文件，并将打包后的资源自动注入到HTML中。它简化了手动创建 HTML 文件的过程，同时提供了一些额外的功能，如压缩HTML、指定模板文件、自定义输出文件名等。</p>\n<h3 id=\"3-2-MiniCssExtractPlugin\"><a href=\"#3-2-MiniCssExtractPlugin\" class=\"headerlink\" title=\"3.2 MiniCssExtractPlugin\"></a>3.2 MiniCssExtractPlugin</h3><p>用于将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载；</p>\n<h3 id=\"3-3-CleanWebpackPlugin\"><a href=\"#3-3-CleanWebpackPlugin\" class=\"headerlink\" title=\"3.3 CleanWebpackPlugin\"></a>3.3 CleanWebpackPlugin</h3><p>用于清理输出目录中的旧文件，确保每次构建都能生成新的输入目录；</p>\n<p>:::warning<br>注：webpack5中已移除，使用 output 中的 clean 配置即可清除 dist 目录<br>:::</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">output: &#123;\n  filename: &#39;bundle.js&#39;,\n  path: path.resolve(__dirname, &#39;dist&#39;),\n  clean: true, &#x2F;&#x2F; 在生成文件之前清空 output 目录\n&#125;,</code></pre>\n\n<h3 id=\"3-4-DefinePlugin\"><a href=\"#3-4-DefinePlugin\" class=\"headerlink\" title=\"3.4 DefinePlugin\"></a>3.4 DefinePlugin</h3><p>用于在编译时将你代码中的变量替换为环境变量，版本信息等配置信息；</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">new webpack.DefinePlugin(&#123;\n  PRODUCTION: JSON.stringify(true),\n  VERSION: JSON.stringify(&#39;1.0.0&#39;),\n&#125;);</code></pre>\n\n<h3 id=\"3-5-HotModuleReplacementPlugin\"><a href=\"#3-5-HotModuleReplacementPlugin\" class=\"headerlink\" title=\"3.5 HotModuleReplacementPlugin\"></a>3.5 HotModuleReplacementPlugin</h3><p>用于启用热模块替换（Hot Module Replacement），热模块替换是一种开发时的特性，它允许在应用程序运行过程中，无需刷新整个页面，只替换发生变化的模块，以实现快速的代码更新和实时预览。</p>\n<p>HMR插件的实现原理如下：</p>\n<ul>\n<li><p>客户端连接：</p>\n<p>HMR插件会在Webpack构建后生成一个运行时客户端，该客户端通过WebSocket与Webpack开发服务器建立连接；</p>\n</li>\n<li><p>监听模块更新：</p>\n<p>HMR插件会在Webpack编译阶段，将需要进行热替换的模块标记为可被接受更新的模块，插件会为这些模块添加监听，以便在模块发生变化时通知客户端；</p>\n</li>\n<li><p>通知客户端：</p>\n<p>当一个模块发生变化时，Webpack会通过WebSocket向运行时客户端发送更新通知，客户端接收到更新通知后，会向Webpack开发服务器发送Ajax请求，获取更新的模块代码；</p>\n</li>\n<li><p>模块替换：</p>\n<p>客户端在接收到新的模块代码后，会利用Webpack的模块热替换接口，将新的模块代码替换掉旧的模块，替换过程中，保留模块的状态（例如表单输入、组件的状态等），以便在替换完成后恢复到之前的状态；</p>\n</li>\n<li><p>更新界面：</p>\n<p>客户端在成功替换模块后，会通知应用程序的其他部分，以便更新界面和执行其他逻辑。</p>\n</li>\n</ul>"},{"title":"FastAPI PostgreSQL 实现 CRUD","date":"2021-08-21T02:30:05.000Z","_content":"\n使用 FastAPI 构建一个CRUD RESTful API，对 PostgreSQL 数据库执行增删改查操作。\n\n<!-- more -->\n\n## 1. 实现结果\n\n|  资源   | 请求方式  |  API   | 描述  | \n|  ----   |   ----  |  ----  | ---- |\n| users  | GET | /api/users | 获取所有用户 |\n| users  | POST| /api/users | 创建一篇用户 |\n| users  | GET | /api/users/:postId | 根据id获取用户详情 |\n| users  | PUT | /api/users/:postId | 根据id更新用户详情 |\n| users  | DELETE| /api/users/:postId | 根据id删除用户 |\n\n\n## 2. 创建FastAPI项目\n\n直接使用 PyCharm 来创建 FastAPI 项目：\n\n![fastapi_create.png](/images/fastapi_create.png)\n\n## 3. 通过 Docker 搭建 PostgreSQL\n\n在根项目中创建 docker-compose.yml 文件并添加以下配置：\n\n```javascript\n// docker-compose.yml\nversion: '3'\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    ports:\n      - '5432:5432'\n    restart: always\n    env_file:\n      - ./.env\n    volumes:\n      - postgres-db:/var/lib/postgresql/data\nvolumes:\n  postgres-db:\n```\n\n然后新建.env文件来保存我们项目中的环境变量：\n\n```shell\n# .env\nDATABASE_PORT=5432\nPOSTGRES_PASSWORD=passwordcrud\nPOSTGRES_USER=postgres\nPOSTGRES_DB=fastcrud\nPOSTGRES_HOST=postgres\nPOSTGRES_HOSTNAME=127.0.0.1\n```\n\n接着，使用以下命令启动 PostgreSQL Docker 容器：\n\n```shell\n$ docker-compose up -d\n```\n\n![fastapi_crud_docker_start](/images/fastapi_crud_docker_start.png)\n\n看到这样的提示的话，说明我们的容器已经启动成功了！❤️\n\n## 4. 数据库连接\n\n接下来，我们需要配置自定义类来读取配置文件，现在创建一个 ``app/config.py`` 文件并添加自定义设置类，我们需要安装一个 pydantic-settings 包，它用于从环境变量加载设置或配置类：\n\n```shell\n$ pip install pydantic-settings\n```\n\n```python\n# app/config.py\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    DATABASE_PORT: int\n    POSTGRES_PASSWORD: str\n    POSTGRES_USER: str\n    POSTGRES_DB: str\n    POSTGRES_HOST: str\n    POSTGRES_HOSTNAME: str\n\n    class Config:\n        env_file = './.env'\n\n\nsettings = Settings()\n```\n\n然后我们安装两个包，一个是 pg 的适配器 psycopg2，以及 ORM SQLAlchemy\n\n```shell \n$ pip install sqlalchemy psycopg2-binary databases\n```\n\n安装完成后，我们新建  ``app/database.py`` 文件来连接 PostgreSQL 服务器：\n\n```python\n# app/database.py\nfrom fastapi import FastAPI\nfrom sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nimport databases\n\nfrom app.config import settings\n\nDATABASE_URL = f\"postgresql://{settings.POSTGRES_USER}:{settings.POSTGRES_PASSWORD}@{settings.POSTGRES_HOSTNAME}/{settings.POSTGRES_DB}\"\n\n# 创建数据库连接对象\ndatabase = databases.Database(DATABASE_URL)\nengine = create_engine(DATABASE_URL)\nmetadata = MetaData(DATABASE_URL)\n\n# 创建会话工厂\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# 创建基类模型\nBase = declarative_base(metadata=metadata)\n```\n\n启动和关闭数据库连接： 在 FastAPI 应用程序中，创建一个启动事件和关闭事件，用于在应用程序启动和关闭时处理数据库连接的打开和关闭：\n\n```python\n# main.py\nfrom fastapi import FastAPI\nfrom app.database import database\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup():\n    await database.connect()\n    try:\n        result = await database.fetch_one(\"SELECT version()\")\n        print(f\"Connected to PostgreSQL. Server version: {result['version']}\")\n    except Exception as e:\n        print(f\"Failed to connect to PostgreSQL: {e}\")\n    finally:\n        await database.disconnect()\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await database.disconnect()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n```\n\n\n## 5. 使用 SQLAlchemy 创建数据库模型\n\n```python\n# app/models.py\nimport uuid\n\nfrom sqlalchemy import TIMESTAMP, Column, String, text\nfrom sqlalchemy.dialects.postgresql import UUID\n\nfrom database import Base\n\n\nclass User(Base):\n    __table_name__ = 'users'\n    id = Column(UUID(as_uuid=True), primary_key=True, nullable=False, default=uuid.uuid4)\n    username = Column(String, nullable=False)\n    username = Column(String, unique=True)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text(\"now()\"))\n    updated_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text(\"now()\"))\n```\n\n## 5. 使用 Pydantic 创建校验规则\n\n```python\n# app/schemas.py\nfrom pydantic import BaseModel\n\nclass UserBaseSchema(BaseModel):\n    username: str\n    email: str\n\n    class Config:\n        from_attributes = True\n\n\nclass CreateUserSchema(UserBaseSchema):\n    pass\n```\n\n## 6. 创建 Controller\n\n```python\n# app/routers/user.py\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter = APIRouter()\n\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter = APIRouter()\n\n@router.post('/', status_code=status.HTTP_201_CREATED)\ndef create_user(user: CreateUserSchema):\n    db = SessionLocal()\n\n    # 创建用户对象\n    db_user = User(username=user.username, email=user.email)\n\n    # 添加用户到会话并提交\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n\n    # 返回创建的用户\n    return db_user\n```","source":"_posts/python/fastapi-crud.md","raw":"---\ntitle: FastAPI PostgreSQL 实现 CRUD\ndate: 2021-08-21 10:30:05\ntags: \n  FastAPI\ncategories:\n  后端技术\n---\n\n使用 FastAPI 构建一个CRUD RESTful API，对 PostgreSQL 数据库执行增删改查操作。\n\n<!-- more -->\n\n## 1. 实现结果\n\n|  资源   | 请求方式  |  API   | 描述  | \n|  ----   |   ----  |  ----  | ---- |\n| users  | GET | /api/users | 获取所有用户 |\n| users  | POST| /api/users | 创建一篇用户 |\n| users  | GET | /api/users/:postId | 根据id获取用户详情 |\n| users  | PUT | /api/users/:postId | 根据id更新用户详情 |\n| users  | DELETE| /api/users/:postId | 根据id删除用户 |\n\n\n## 2. 创建FastAPI项目\n\n直接使用 PyCharm 来创建 FastAPI 项目：\n\n![fastapi_create.png](/images/fastapi_create.png)\n\n## 3. 通过 Docker 搭建 PostgreSQL\n\n在根项目中创建 docker-compose.yml 文件并添加以下配置：\n\n```javascript\n// docker-compose.yml\nversion: '3'\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    ports:\n      - '5432:5432'\n    restart: always\n    env_file:\n      - ./.env\n    volumes:\n      - postgres-db:/var/lib/postgresql/data\nvolumes:\n  postgres-db:\n```\n\n然后新建.env文件来保存我们项目中的环境变量：\n\n```shell\n# .env\nDATABASE_PORT=5432\nPOSTGRES_PASSWORD=passwordcrud\nPOSTGRES_USER=postgres\nPOSTGRES_DB=fastcrud\nPOSTGRES_HOST=postgres\nPOSTGRES_HOSTNAME=127.0.0.1\n```\n\n接着，使用以下命令启动 PostgreSQL Docker 容器：\n\n```shell\n$ docker-compose up -d\n```\n\n![fastapi_crud_docker_start](/images/fastapi_crud_docker_start.png)\n\n看到这样的提示的话，说明我们的容器已经启动成功了！❤️\n\n## 4. 数据库连接\n\n接下来，我们需要配置自定义类来读取配置文件，现在创建一个 ``app/config.py`` 文件并添加自定义设置类，我们需要安装一个 pydantic-settings 包，它用于从环境变量加载设置或配置类：\n\n```shell\n$ pip install pydantic-settings\n```\n\n```python\n# app/config.py\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    DATABASE_PORT: int\n    POSTGRES_PASSWORD: str\n    POSTGRES_USER: str\n    POSTGRES_DB: str\n    POSTGRES_HOST: str\n    POSTGRES_HOSTNAME: str\n\n    class Config:\n        env_file = './.env'\n\n\nsettings = Settings()\n```\n\n然后我们安装两个包，一个是 pg 的适配器 psycopg2，以及 ORM SQLAlchemy\n\n```shell \n$ pip install sqlalchemy psycopg2-binary databases\n```\n\n安装完成后，我们新建  ``app/database.py`` 文件来连接 PostgreSQL 服务器：\n\n```python\n# app/database.py\nfrom fastapi import FastAPI\nfrom sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nimport databases\n\nfrom app.config import settings\n\nDATABASE_URL = f\"postgresql://{settings.POSTGRES_USER}:{settings.POSTGRES_PASSWORD}@{settings.POSTGRES_HOSTNAME}/{settings.POSTGRES_DB}\"\n\n# 创建数据库连接对象\ndatabase = databases.Database(DATABASE_URL)\nengine = create_engine(DATABASE_URL)\nmetadata = MetaData(DATABASE_URL)\n\n# 创建会话工厂\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# 创建基类模型\nBase = declarative_base(metadata=metadata)\n```\n\n启动和关闭数据库连接： 在 FastAPI 应用程序中，创建一个启动事件和关闭事件，用于在应用程序启动和关闭时处理数据库连接的打开和关闭：\n\n```python\n# main.py\nfrom fastapi import FastAPI\nfrom app.database import database\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup():\n    await database.connect()\n    try:\n        result = await database.fetch_one(\"SELECT version()\")\n        print(f\"Connected to PostgreSQL. Server version: {result['version']}\")\n    except Exception as e:\n        print(f\"Failed to connect to PostgreSQL: {e}\")\n    finally:\n        await database.disconnect()\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await database.disconnect()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n```\n\n\n## 5. 使用 SQLAlchemy 创建数据库模型\n\n```python\n# app/models.py\nimport uuid\n\nfrom sqlalchemy import TIMESTAMP, Column, String, text\nfrom sqlalchemy.dialects.postgresql import UUID\n\nfrom database import Base\n\n\nclass User(Base):\n    __table_name__ = 'users'\n    id = Column(UUID(as_uuid=True), primary_key=True, nullable=False, default=uuid.uuid4)\n    username = Column(String, nullable=False)\n    username = Column(String, unique=True)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text(\"now()\"))\n    updated_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text(\"now()\"))\n```\n\n## 5. 使用 Pydantic 创建校验规则\n\n```python\n# app/schemas.py\nfrom pydantic import BaseModel\n\nclass UserBaseSchema(BaseModel):\n    username: str\n    email: str\n\n    class Config:\n        from_attributes = True\n\n\nclass CreateUserSchema(UserBaseSchema):\n    pass\n```\n\n## 6. 创建 Controller\n\n```python\n# app/routers/user.py\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter = APIRouter()\n\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter = APIRouter()\n\n@router.post('/', status_code=status.HTTP_201_CREATED)\ndef create_user(user: CreateUserSchema):\n    db = SessionLocal()\n\n    # 创建用户对象\n    db_user = User(username=user.username, email=user.email)\n\n    # 添加用户到会话并提交\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n\n    # 返回创建的用户\n    return db_user\n```","slug":"python/fastapi-crud","published":1,"updated":"2023-07-18T05:46:02.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkkjvrem0000602zb9xsgz3a","content":"<p>使用 FastAPI 构建一个CRUD RESTful API，对 PostgreSQL 数据库执行增删改查操作。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-实现结果\"><a href=\"#1-实现结果\" class=\"headerlink\" title=\"1. 实现结果\"></a>1. 实现结果</h2><table>\n<thead>\n<tr>\n<th>资源</th>\n<th>请求方式</th>\n<th>API</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>users</td>\n<td>GET</td>\n<td>&#x2F;api&#x2F;users</td>\n<td>获取所有用户</td>\n</tr>\n<tr>\n<td>users</td>\n<td>POST</td>\n<td>&#x2F;api&#x2F;users</td>\n<td>创建一篇用户</td>\n</tr>\n<tr>\n<td>users</td>\n<td>GET</td>\n<td>&#x2F;api&#x2F;users&#x2F;:postId</td>\n<td>根据id获取用户详情</td>\n</tr>\n<tr>\n<td>users</td>\n<td>PUT</td>\n<td>&#x2F;api&#x2F;users&#x2F;:postId</td>\n<td>根据id更新用户详情</td>\n</tr>\n<tr>\n<td>users</td>\n<td>DELETE</td>\n<td>&#x2F;api&#x2F;users&#x2F;:postId</td>\n<td>根据id删除用户</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-创建FastAPI项目\"><a href=\"#2-创建FastAPI项目\" class=\"headerlink\" title=\"2. 创建FastAPI项目\"></a>2. 创建FastAPI项目</h2><p>直接使用 PyCharm 来创建 FastAPI 项目：</p>\n<p><img src=\"/images/fastapi_create.png\" alt=\"fastapi_create.png\"></p>\n<h2 id=\"3-通过-Docker-搭建-PostgreSQL\"><a href=\"#3-通过-Docker-搭建-PostgreSQL\" class=\"headerlink\" title=\"3. 通过 Docker 搭建 PostgreSQL\"></a>3. 通过 Docker 搭建 PostgreSQL</h2><p>在根项目中创建 docker-compose.yml 文件并添加以下配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; docker-compose.yml\nversion: &#39;3&#39;\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    ports:\n      - &#39;5432:5432&#39;\n    restart: always\n    env_file:\n      - .&#x2F;.env\n    volumes:\n      - postgres-db:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data\nvolumes:\n  postgres-db:</code></pre>\n\n<p>然后新建.env文件来保存我们项目中的环境变量：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># .env\nDATABASE_PORT&#x3D;5432\nPOSTGRES_PASSWORD&#x3D;passwordcrud\nPOSTGRES_USER&#x3D;postgres\nPOSTGRES_DB&#x3D;fastcrud\nPOSTGRES_HOST&#x3D;postgres\nPOSTGRES_HOSTNAME&#x3D;127.0.0.1</code></pre>\n\n<p>接着，使用以下命令启动 PostgreSQL Docker 容器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker-compose up -d</code></pre>\n\n<p><img src=\"/images/fastapi_crud_docker_start.png\" alt=\"fastapi_crud_docker_start\"></p>\n<p>看到这样的提示的话，说明我们的容器已经启动成功了！❤️</p>\n<h2 id=\"4-数据库连接\"><a href=\"#4-数据库连接\" class=\"headerlink\" title=\"4. 数据库连接\"></a>4. 数据库连接</h2><p>接下来，我们需要配置自定义类来读取配置文件，现在创建一个 <code>app/config.py</code> 文件并添加自定义设置类，我们需要安装一个 pydantic-settings 包，它用于从环境变量加载设置或配置类：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ pip install pydantic-settings</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;config.py\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    DATABASE_PORT: int\n    POSTGRES_PASSWORD: str\n    POSTGRES_USER: str\n    POSTGRES_DB: str\n    POSTGRES_HOST: str\n    POSTGRES_HOSTNAME: str\n\n    class Config:\n        env_file &#x3D; &#39;.&#x2F;.env&#39;\n\n\nsettings &#x3D; Settings()</code></pre>\n\n<p>然后我们安装两个包，一个是 pg 的适配器 psycopg2，以及 ORM SQLAlchemy</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ pip install sqlalchemy psycopg2-binary databases</code></pre>\n\n<p>安装完成后，我们新建  <code>app/database.py</code> 文件来连接 PostgreSQL 服务器：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;database.py\nfrom fastapi import FastAPI\nfrom sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nimport databases\n\nfrom app.config import settings\n\nDATABASE_URL &#x3D; f&quot;postgresql:&#x2F;&#x2F;&#123;settings.POSTGRES_USER&#125;:&#123;settings.POSTGRES_PASSWORD&#125;@&#123;settings.POSTGRES_HOSTNAME&#125;&#x2F;&#123;settings.POSTGRES_DB&#125;&quot;\n\n# 创建数据库连接对象\ndatabase &#x3D; databases.Database(DATABASE_URL)\nengine &#x3D; create_engine(DATABASE_URL)\nmetadata &#x3D; MetaData(DATABASE_URL)\n\n# 创建会话工厂\nSessionLocal &#x3D; sessionmaker(autocommit&#x3D;False, autoflush&#x3D;False, bind&#x3D;engine)\n\n# 创建基类模型\nBase &#x3D; declarative_base(metadata&#x3D;metadata)</code></pre>\n\n<p>启动和关闭数据库连接： 在 FastAPI 应用程序中，创建一个启动事件和关闭事件，用于在应用程序启动和关闭时处理数据库连接的打开和关闭：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># main.py\nfrom fastapi import FastAPI\nfrom app.database import database\n\napp &#x3D; FastAPI()\n\n@app.on_event(&quot;startup&quot;)\nasync def startup():\n    await database.connect()\n    try:\n        result &#x3D; await database.fetch_one(&quot;SELECT version()&quot;)\n        print(f&quot;Connected to PostgreSQL. Server version: &#123;result[&#39;version&#39;]&#125;&quot;)\n    except Exception as e:\n        print(f&quot;Failed to connect to PostgreSQL: &#123;e&#125;&quot;)\n    finally:\n        await database.disconnect()\n\n@app.on_event(&quot;shutdown&quot;)\nasync def shutdown():\n    await database.disconnect()\n\n@app.get(&quot;&#x2F;&quot;)\nasync def root():\n    return &#123;&quot;message&quot;: &quot;Hello World&quot;&#125;\n</code></pre>\n\n\n<h2 id=\"5-使用-SQLAlchemy-创建数据库模型\"><a href=\"#5-使用-SQLAlchemy-创建数据库模型\" class=\"headerlink\" title=\"5. 使用 SQLAlchemy 创建数据库模型\"></a>5. 使用 SQLAlchemy 创建数据库模型</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;models.py\nimport uuid\n\nfrom sqlalchemy import TIMESTAMP, Column, String, text\nfrom sqlalchemy.dialects.postgresql import UUID\n\nfrom database import Base\n\n\nclass User(Base):\n    __table_name__ &#x3D; &#39;users&#39;\n    id &#x3D; Column(UUID(as_uuid&#x3D;True), primary_key&#x3D;True, nullable&#x3D;False, default&#x3D;uuid.uuid4)\n    username &#x3D; Column(String, nullable&#x3D;False)\n    username &#x3D; Column(String, unique&#x3D;True)\n    created_at &#x3D; Column(TIMESTAMP(timezone&#x3D;True), nullable&#x3D;False, server_default&#x3D;text(&quot;now()&quot;))\n    updated_at &#x3D; Column(TIMESTAMP(timezone&#x3D;True), nullable&#x3D;False, server_default&#x3D;text(&quot;now()&quot;))</code></pre>\n\n<h2 id=\"5-使用-Pydantic-创建校验规则\"><a href=\"#5-使用-Pydantic-创建校验规则\" class=\"headerlink\" title=\"5. 使用 Pydantic 创建校验规则\"></a>5. 使用 Pydantic 创建校验规则</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;schemas.py\nfrom pydantic import BaseModel\n\nclass UserBaseSchema(BaseModel):\n    username: str\n    email: str\n\n    class Config:\n        from_attributes &#x3D; True\n\n\nclass CreateUserSchema(UserBaseSchema):\n    pass</code></pre>\n\n<h2 id=\"6-创建-Controller\"><a href=\"#6-创建-Controller\" class=\"headerlink\" title=\"6. 创建 Controller\"></a>6. 创建 Controller</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;routers&#x2F;user.py\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter &#x3D; APIRouter()\n\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter &#x3D; APIRouter()\n\n@router.post(&#39;&#x2F;&#39;, status_code&#x3D;status.HTTP_201_CREATED)\ndef create_user(user: CreateUserSchema):\n    db &#x3D; SessionLocal()\n\n    # 创建用户对象\n    db_user &#x3D; User(username&#x3D;user.username, email&#x3D;user.email)\n\n    # 添加用户到会话并提交\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n\n    # 返回创建的用户\n    return db_user</code></pre>","site":{"data":{}},"excerpt":"<p>使用 FastAPI 构建一个CRUD RESTful API，对 PostgreSQL 数据库执行增删改查操作。</p>","more":"<h2 id=\"1-实现结果\"><a href=\"#1-实现结果\" class=\"headerlink\" title=\"1. 实现结果\"></a>1. 实现结果</h2><table>\n<thead>\n<tr>\n<th>资源</th>\n<th>请求方式</th>\n<th>API</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>users</td>\n<td>GET</td>\n<td>&#x2F;api&#x2F;users</td>\n<td>获取所有用户</td>\n</tr>\n<tr>\n<td>users</td>\n<td>POST</td>\n<td>&#x2F;api&#x2F;users</td>\n<td>创建一篇用户</td>\n</tr>\n<tr>\n<td>users</td>\n<td>GET</td>\n<td>&#x2F;api&#x2F;users&#x2F;:postId</td>\n<td>根据id获取用户详情</td>\n</tr>\n<tr>\n<td>users</td>\n<td>PUT</td>\n<td>&#x2F;api&#x2F;users&#x2F;:postId</td>\n<td>根据id更新用户详情</td>\n</tr>\n<tr>\n<td>users</td>\n<td>DELETE</td>\n<td>&#x2F;api&#x2F;users&#x2F;:postId</td>\n<td>根据id删除用户</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-创建FastAPI项目\"><a href=\"#2-创建FastAPI项目\" class=\"headerlink\" title=\"2. 创建FastAPI项目\"></a>2. 创建FastAPI项目</h2><p>直接使用 PyCharm 来创建 FastAPI 项目：</p>\n<p><img src=\"/images/fastapi_create.png\" alt=\"fastapi_create.png\"></p>\n<h2 id=\"3-通过-Docker-搭建-PostgreSQL\"><a href=\"#3-通过-Docker-搭建-PostgreSQL\" class=\"headerlink\" title=\"3. 通过 Docker 搭建 PostgreSQL\"></a>3. 通过 Docker 搭建 PostgreSQL</h2><p>在根项目中创建 docker-compose.yml 文件并添加以下配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; docker-compose.yml\nversion: &#39;3&#39;\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    ports:\n      - &#39;5432:5432&#39;\n    restart: always\n    env_file:\n      - .&#x2F;.env\n    volumes:\n      - postgres-db:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data\nvolumes:\n  postgres-db:</code></pre>\n\n<p>然后新建.env文件来保存我们项目中的环境变量：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># .env\nDATABASE_PORT&#x3D;5432\nPOSTGRES_PASSWORD&#x3D;passwordcrud\nPOSTGRES_USER&#x3D;postgres\nPOSTGRES_DB&#x3D;fastcrud\nPOSTGRES_HOST&#x3D;postgres\nPOSTGRES_HOSTNAME&#x3D;127.0.0.1</code></pre>\n\n<p>接着，使用以下命令启动 PostgreSQL Docker 容器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker-compose up -d</code></pre>\n\n<p><img src=\"/images/fastapi_crud_docker_start.png\" alt=\"fastapi_crud_docker_start\"></p>\n<p>看到这样的提示的话，说明我们的容器已经启动成功了！❤️</p>\n<h2 id=\"4-数据库连接\"><a href=\"#4-数据库连接\" class=\"headerlink\" title=\"4. 数据库连接\"></a>4. 数据库连接</h2><p>接下来，我们需要配置自定义类来读取配置文件，现在创建一个 <code>app/config.py</code> 文件并添加自定义设置类，我们需要安装一个 pydantic-settings 包，它用于从环境变量加载设置或配置类：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ pip install pydantic-settings</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;config.py\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    DATABASE_PORT: int\n    POSTGRES_PASSWORD: str\n    POSTGRES_USER: str\n    POSTGRES_DB: str\n    POSTGRES_HOST: str\n    POSTGRES_HOSTNAME: str\n\n    class Config:\n        env_file &#x3D; &#39;.&#x2F;.env&#39;\n\n\nsettings &#x3D; Settings()</code></pre>\n\n<p>然后我们安装两个包，一个是 pg 的适配器 psycopg2，以及 ORM SQLAlchemy</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ pip install sqlalchemy psycopg2-binary databases</code></pre>\n\n<p>安装完成后，我们新建  <code>app/database.py</code> 文件来连接 PostgreSQL 服务器：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;database.py\nfrom fastapi import FastAPI\nfrom sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nimport databases\n\nfrom app.config import settings\n\nDATABASE_URL &#x3D; f&quot;postgresql:&#x2F;&#x2F;&#123;settings.POSTGRES_USER&#125;:&#123;settings.POSTGRES_PASSWORD&#125;@&#123;settings.POSTGRES_HOSTNAME&#125;&#x2F;&#123;settings.POSTGRES_DB&#125;&quot;\n\n# 创建数据库连接对象\ndatabase &#x3D; databases.Database(DATABASE_URL)\nengine &#x3D; create_engine(DATABASE_URL)\nmetadata &#x3D; MetaData(DATABASE_URL)\n\n# 创建会话工厂\nSessionLocal &#x3D; sessionmaker(autocommit&#x3D;False, autoflush&#x3D;False, bind&#x3D;engine)\n\n# 创建基类模型\nBase &#x3D; declarative_base(metadata&#x3D;metadata)</code></pre>\n\n<p>启动和关闭数据库连接： 在 FastAPI 应用程序中，创建一个启动事件和关闭事件，用于在应用程序启动和关闭时处理数据库连接的打开和关闭：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># main.py\nfrom fastapi import FastAPI\nfrom app.database import database\n\napp &#x3D; FastAPI()\n\n@app.on_event(&quot;startup&quot;)\nasync def startup():\n    await database.connect()\n    try:\n        result &#x3D; await database.fetch_one(&quot;SELECT version()&quot;)\n        print(f&quot;Connected to PostgreSQL. Server version: &#123;result[&#39;version&#39;]&#125;&quot;)\n    except Exception as e:\n        print(f&quot;Failed to connect to PostgreSQL: &#123;e&#125;&quot;)\n    finally:\n        await database.disconnect()\n\n@app.on_event(&quot;shutdown&quot;)\nasync def shutdown():\n    await database.disconnect()\n\n@app.get(&quot;&#x2F;&quot;)\nasync def root():\n    return &#123;&quot;message&quot;: &quot;Hello World&quot;&#125;\n</code></pre>\n\n\n<h2 id=\"5-使用-SQLAlchemy-创建数据库模型\"><a href=\"#5-使用-SQLAlchemy-创建数据库模型\" class=\"headerlink\" title=\"5. 使用 SQLAlchemy 创建数据库模型\"></a>5. 使用 SQLAlchemy 创建数据库模型</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;models.py\nimport uuid\n\nfrom sqlalchemy import TIMESTAMP, Column, String, text\nfrom sqlalchemy.dialects.postgresql import UUID\n\nfrom database import Base\n\n\nclass User(Base):\n    __table_name__ &#x3D; &#39;users&#39;\n    id &#x3D; Column(UUID(as_uuid&#x3D;True), primary_key&#x3D;True, nullable&#x3D;False, default&#x3D;uuid.uuid4)\n    username &#x3D; Column(String, nullable&#x3D;False)\n    username &#x3D; Column(String, unique&#x3D;True)\n    created_at &#x3D; Column(TIMESTAMP(timezone&#x3D;True), nullable&#x3D;False, server_default&#x3D;text(&quot;now()&quot;))\n    updated_at &#x3D; Column(TIMESTAMP(timezone&#x3D;True), nullable&#x3D;False, server_default&#x3D;text(&quot;now()&quot;))</code></pre>\n\n<h2 id=\"5-使用-Pydantic-创建校验规则\"><a href=\"#5-使用-Pydantic-创建校验规则\" class=\"headerlink\" title=\"5. 使用 Pydantic 创建校验规则\"></a>5. 使用 Pydantic 创建校验规则</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;schemas.py\nfrom pydantic import BaseModel\n\nclass UserBaseSchema(BaseModel):\n    username: str\n    email: str\n\n    class Config:\n        from_attributes &#x3D; True\n\n\nclass CreateUserSchema(UserBaseSchema):\n    pass</code></pre>\n\n<h2 id=\"6-创建-Controller\"><a href=\"#6-创建-Controller\" class=\"headerlink\" title=\"6. 创建 Controller\"></a>6. 创建 Controller</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># app&#x2F;routers&#x2F;user.py\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter &#x3D; APIRouter()\n\nfrom fastapi import APIRouter\nfrom starlette import status\n\nfrom app.database import SessionLocal\nfrom app.models import User\nfrom app.schemas import CreateUserSchema\n\nrouter &#x3D; APIRouter()\n\n@router.post(&#39;&#x2F;&#39;, status_code&#x3D;status.HTTP_201_CREATED)\ndef create_user(user: CreateUserSchema):\n    db &#x3D; SessionLocal()\n\n    # 创建用户对象\n    db_user &#x3D; User(username&#x3D;user.username, email&#x3D;user.email)\n\n    # 添加用户到会话并提交\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n\n    # 返回创建的用户\n    return db_user</code></pre>"},{"title":"FastAPI 入门介绍","date":"2021-08-20T07:46:53.000Z","_content":"\nFastAPI 是一个现代化的 Python Web 框架，用于构建高性能的 Web 应用程序和 API。它基于 Python 3.7+ 中的异步框架 starlette，并提供了简单、快速和易于使用的方式来创建 Web 服务。\n\n<!-- more -->\n\n## 1. 特点和优势：\n\n- 高性能：FastAPI 基于异步编程模型，利用 Python 3.7+ 中引入的 asyncio 和 await 特性，以及 starlette 框架的异步支持，实现了卓越的性能和并发处理能力；\n- 快速开发：FastAPI 提供了简洁且易于理解的 API，可以快速定义路由、请求验证、数据序列化和文档生成等功能，从而加快了开发速度；\n- 类型注解和自动文档生成： FastAPI 使用 Python 3.7+ 的类型注解特性，可以提供静态类型检查和自动文档生成。它使用 Pydantic 库来处理数据验证和序列化，并基于 API 路由的定义自动生成交互式文档（如 Swagger UI 和 ReDoc）；\n- 规范标准：FastAPI 遵循 OpenAPI（以前称为 Swagger）和 JSON Schema 等标准，使得它与其他工具和服务（如 Swagger UI、ReDoc、自动化测试和代码生成工具）的集成更加容易；\n- 强大的请求处理：FastAPI 支持请求参数的自动解析和验证，可以处理路径参数、查询参数、请求体、表单数据、文件上传等各种类型的请求数据；\n- WebSocket 支持：FastAPI 内置对 WebSocket 的支持，可以轻松处理实时双向通信的需求；\n- 安全性：FastAPI 提供了内置的身份验证和授权支持，可以轻松集成认证方案，如 OAuth2、JWT 等；\n\n\n## 2. 安装与运行\n\n```shell\n$ pip install fastapi\n$ pip install \"uvicorn[standard]\"\n```\n\n```python\n# main.py\n\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n\n```\n\n```shell\n$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```","source":"_posts/python/fastapi-intro.md","raw":"---\ntitle: FastAPI 入门介绍\ndate: 2021-08-20 15:46:53\ntags: \n  FastAPI\ncategories:\n  后端技术\n---\n\nFastAPI 是一个现代化的 Python Web 框架，用于构建高性能的 Web 应用程序和 API。它基于 Python 3.7+ 中的异步框架 starlette，并提供了简单、快速和易于使用的方式来创建 Web 服务。\n\n<!-- more -->\n\n## 1. 特点和优势：\n\n- 高性能：FastAPI 基于异步编程模型，利用 Python 3.7+ 中引入的 asyncio 和 await 特性，以及 starlette 框架的异步支持，实现了卓越的性能和并发处理能力；\n- 快速开发：FastAPI 提供了简洁且易于理解的 API，可以快速定义路由、请求验证、数据序列化和文档生成等功能，从而加快了开发速度；\n- 类型注解和自动文档生成： FastAPI 使用 Python 3.7+ 的类型注解特性，可以提供静态类型检查和自动文档生成。它使用 Pydantic 库来处理数据验证和序列化，并基于 API 路由的定义自动生成交互式文档（如 Swagger UI 和 ReDoc）；\n- 规范标准：FastAPI 遵循 OpenAPI（以前称为 Swagger）和 JSON Schema 等标准，使得它与其他工具和服务（如 Swagger UI、ReDoc、自动化测试和代码生成工具）的集成更加容易；\n- 强大的请求处理：FastAPI 支持请求参数的自动解析和验证，可以处理路径参数、查询参数、请求体、表单数据、文件上传等各种类型的请求数据；\n- WebSocket 支持：FastAPI 内置对 WebSocket 的支持，可以轻松处理实时双向通信的需求；\n- 安全性：FastAPI 提供了内置的身份验证和授权支持，可以轻松集成认证方案，如 OAuth2、JWT 等；\n\n\n## 2. 安装与运行\n\n```shell\n$ pip install fastapi\n$ pip install \"uvicorn[standard]\"\n```\n\n```python\n# main.py\n\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n\n```\n\n```shell\n$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```","slug":"python/fastapi-intro","published":1,"updated":"2023-07-17T02:37:41.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkkjvreq0001602z4v2x36q7","content":"<p>FastAPI 是一个现代化的 Python Web 框架，用于构建高性能的 Web 应用程序和 API。它基于 Python 3.7+ 中的异步框架 starlette，并提供了简单、快速和易于使用的方式来创建 Web 服务。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-特点和优势：\"><a href=\"#1-特点和优势：\" class=\"headerlink\" title=\"1. 特点和优势：\"></a>1. 特点和优势：</h2><ul>\n<li>高性能：FastAPI 基于异步编程模型，利用 Python 3.7+ 中引入的 asyncio 和 await 特性，以及 starlette 框架的异步支持，实现了卓越的性能和并发处理能力；</li>\n<li>快速开发：FastAPI 提供了简洁且易于理解的 API，可以快速定义路由、请求验证、数据序列化和文档生成等功能，从而加快了开发速度；</li>\n<li>类型注解和自动文档生成： FastAPI 使用 Python 3.7+ 的类型注解特性，可以提供静态类型检查和自动文档生成。它使用 Pydantic 库来处理数据验证和序列化，并基于 API 路由的定义自动生成交互式文档（如 Swagger UI 和 ReDoc）；</li>\n<li>规范标准：FastAPI 遵循 OpenAPI（以前称为 Swagger）和 JSON Schema 等标准，使得它与其他工具和服务（如 Swagger UI、ReDoc、自动化测试和代码生成工具）的集成更加容易；</li>\n<li>强大的请求处理：FastAPI 支持请求参数的自动解析和验证，可以处理路径参数、查询参数、请求体、表单数据、文件上传等各种类型的请求数据；</li>\n<li>WebSocket 支持：FastAPI 内置对 WebSocket 的支持，可以轻松处理实时双向通信的需求；</li>\n<li>安全性：FastAPI 提供了内置的身份验证和授权支持，可以轻松集成认证方案，如 OAuth2、JWT 等；</li>\n</ul>\n<h2 id=\"2-安装与运行\"><a href=\"#2-安装与运行\" class=\"headerlink\" title=\"2. 安装与运行\"></a>2. 安装与运行</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ pip install fastapi\n$ pip install &quot;uvicorn[standard]&quot;</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># main.py\n\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp &#x3D; FastAPI()\n\n@app.get(&quot;&#x2F;&quot;)\ndef read_root():\n    return &#123;&quot;Hello&quot;: &quot;World&quot;&#125;\n\n@app.get(&quot;&#x2F;items&#x2F;&#123;item_id&#125;&quot;)\nasync def read_item(item_id: int, q: Union[str, None] &#x3D; None):\n    return &#123;&quot;item_id&quot;: item_id, &quot;q&quot;: q&#125;\n</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http:&#x2F;&#x2F;127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.</code></pre>","site":{"data":{}},"excerpt":"<p>FastAPI 是一个现代化的 Python Web 框架，用于构建高性能的 Web 应用程序和 API。它基于 Python 3.7+ 中的异步框架 starlette，并提供了简单、快速和易于使用的方式来创建 Web 服务。</p>","more":"<h2 id=\"1-特点和优势：\"><a href=\"#1-特点和优势：\" class=\"headerlink\" title=\"1. 特点和优势：\"></a>1. 特点和优势：</h2><ul>\n<li>高性能：FastAPI 基于异步编程模型，利用 Python 3.7+ 中引入的 asyncio 和 await 特性，以及 starlette 框架的异步支持，实现了卓越的性能和并发处理能力；</li>\n<li>快速开发：FastAPI 提供了简洁且易于理解的 API，可以快速定义路由、请求验证、数据序列化和文档生成等功能，从而加快了开发速度；</li>\n<li>类型注解和自动文档生成： FastAPI 使用 Python 3.7+ 的类型注解特性，可以提供静态类型检查和自动文档生成。它使用 Pydantic 库来处理数据验证和序列化，并基于 API 路由的定义自动生成交互式文档（如 Swagger UI 和 ReDoc）；</li>\n<li>规范标准：FastAPI 遵循 OpenAPI（以前称为 Swagger）和 JSON Schema 等标准，使得它与其他工具和服务（如 Swagger UI、ReDoc、自动化测试和代码生成工具）的集成更加容易；</li>\n<li>强大的请求处理：FastAPI 支持请求参数的自动解析和验证，可以处理路径参数、查询参数、请求体、表单数据、文件上传等各种类型的请求数据；</li>\n<li>WebSocket 支持：FastAPI 内置对 WebSocket 的支持，可以轻松处理实时双向通信的需求；</li>\n<li>安全性：FastAPI 提供了内置的身份验证和授权支持，可以轻松集成认证方案，如 OAuth2、JWT 等；</li>\n</ul>\n<h2 id=\"2-安装与运行\"><a href=\"#2-安装与运行\" class=\"headerlink\" title=\"2. 安装与运行\"></a>2. 安装与运行</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ pip install fastapi\n$ pip install &quot;uvicorn[standard]&quot;</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># main.py\n\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp &#x3D; FastAPI()\n\n@app.get(&quot;&#x2F;&quot;)\ndef read_root():\n    return &#123;&quot;Hello&quot;: &quot;World&quot;&#125;\n\n@app.get(&quot;&#x2F;items&#x2F;&#123;item_id&#125;&quot;)\nasync def read_item(item_id: int, q: Union[str, None] &#x3D; None):\n    return &#123;&quot;item_id&quot;: item_id, &quot;q&quot;: q&#125;\n</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http:&#x2F;&#x2F;127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.</code></pre>"},{"title":"PostgreSQL 常用命令","date":"2023-07-25T13:20:27.000Z","_content":"\nPostgreSQL 是一个强大的开源关系型数据库管理系统（RDBMS），它支持大部分SQL标准，并提供了许多高级特性和扩展功能，记录一下常用命令。\n\n## 1. 创建数据库\n\n```shell\n$ create database <database-name>\n```\n\n## 2. 删除数据库\n\n```shell\n$ drop database <database-name>\n```\n\n## 3. 创建表\n\n```shell\n$ create table <table-name>\n```\n\n## 4. 单表查询\n\n```shell\n# 所有列\n$ select * from <table-name>\n# 单列\n$ select <column-name> from <table-name>\n# 多列\n$ select <column-name1>, <column-name2> from <table-name>\n# 连接运算符，合并多列结果\n$ select <column-name1> || '' || <column-name2> from <table-name>\n# 列别名\n$ select <column-name> as(可省略) <column-name-alias> from <table-name>\n```\n\n## 5. ORDER BY\n\n根据排序表达式按升序或降序对SELECT返回的行进行排序","source":"_posts/sql/pg/common.md","raw":"---\ntitle: PostgreSQL 常用命令\ndate: 2023-07-25 21:20:27\ntags: \n  PostgreSQL\ncategories:\n  数据库\n---\n\nPostgreSQL 是一个强大的开源关系型数据库管理系统（RDBMS），它支持大部分SQL标准，并提供了许多高级特性和扩展功能，记录一下常用命令。\n\n## 1. 创建数据库\n\n```shell\n$ create database <database-name>\n```\n\n## 2. 删除数据库\n\n```shell\n$ drop database <database-name>\n```\n\n## 3. 创建表\n\n```shell\n$ create table <table-name>\n```\n\n## 4. 单表查询\n\n```shell\n# 所有列\n$ select * from <table-name>\n# 单列\n$ select <column-name> from <table-name>\n# 多列\n$ select <column-name1>, <column-name2> from <table-name>\n# 连接运算符，合并多列结果\n$ select <column-name1> || '' || <column-name2> from <table-name>\n# 列别名\n$ select <column-name> as(可省略) <column-name-alias> from <table-name>\n```\n\n## 5. ORDER BY\n\n根据排序表达式按升序或降序对SELECT返回的行进行排序","slug":"sql/pg/common","published":1,"updated":"2023-07-27T02:43:03.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkkjvrew0004602zfgqk6s0d","content":"<p>PostgreSQL 是一个强大的开源关系型数据库管理系统（RDBMS），它支持大部分SQL标准，并提供了许多高级特性和扩展功能，记录一下常用命令。</p>\n<h2 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1. 创建数据库\"></a>1. 创建数据库</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ create database &lt;database-name&gt;</code></pre>\n\n<h2 id=\"2-删除数据库\"><a href=\"#2-删除数据库\" class=\"headerlink\" title=\"2. 删除数据库\"></a>2. 删除数据库</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ drop database &lt;database-name&gt;</code></pre>\n\n<h2 id=\"3-创建表\"><a href=\"#3-创建表\" class=\"headerlink\" title=\"3. 创建表\"></a>3. 创建表</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ create table &lt;table-name&gt;</code></pre>\n\n<h2 id=\"4-单表查询\"><a href=\"#4-单表查询\" class=\"headerlink\" title=\"4. 单表查询\"></a>4. 单表查询</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 所有列\n$ select * from &lt;table-name&gt;\n# 单列\n$ select &lt;column-name&gt; from &lt;table-name&gt;\n# 多列\n$ select &lt;column-name1&gt;, &lt;column-name2&gt; from &lt;table-name&gt;\n# 连接运算符，合并多列结果\n$ select &lt;column-name1&gt; || &#39;&#39; || &lt;column-name2&gt; from &lt;table-name&gt;\n# 列别名\n$ select &lt;column-name&gt; as(可省略) &lt;column-name-alias&gt; from &lt;table-name&gt;</code></pre>\n\n<h2 id=\"5-ORDER-BY\"><a href=\"#5-ORDER-BY\" class=\"headerlink\" title=\"5. ORDER BY\"></a>5. ORDER BY</h2><p>根据排序表达式按升序或降序对SELECT返回的行进行排序</p>\n","site":{"data":{}},"excerpt":"","more":"<p>PostgreSQL 是一个强大的开源关系型数据库管理系统（RDBMS），它支持大部分SQL标准，并提供了许多高级特性和扩展功能，记录一下常用命令。</p>\n<h2 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1. 创建数据库\"></a>1. 创建数据库</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ create database &lt;database-name&gt;</code></pre>\n\n<h2 id=\"2-删除数据库\"><a href=\"#2-删除数据库\" class=\"headerlink\" title=\"2. 删除数据库\"></a>2. 删除数据库</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ drop database &lt;database-name&gt;</code></pre>\n\n<h2 id=\"3-创建表\"><a href=\"#3-创建表\" class=\"headerlink\" title=\"3. 创建表\"></a>3. 创建表</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ create table &lt;table-name&gt;</code></pre>\n\n<h2 id=\"4-单表查询\"><a href=\"#4-单表查询\" class=\"headerlink\" title=\"4. 单表查询\"></a>4. 单表查询</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 所有列\n$ select * from &lt;table-name&gt;\n# 单列\n$ select &lt;column-name&gt; from &lt;table-name&gt;\n# 多列\n$ select &lt;column-name1&gt;, &lt;column-name2&gt; from &lt;table-name&gt;\n# 连接运算符，合并多列结果\n$ select &lt;column-name1&gt; || &#39;&#39; || &lt;column-name2&gt; from &lt;table-name&gt;\n# 列别名\n$ select &lt;column-name&gt; as(可省略) &lt;column-name-alias&gt; from &lt;table-name&gt;</code></pre>\n\n<h2 id=\"5-ORDER-BY\"><a href=\"#5-ORDER-BY\" class=\"headerlink\" title=\"5. ORDER BY\"></a>5. ORDER BY</h2><p>根据排序表达式按升序或降序对SELECT返回的行进行排序</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cljo05xi00006322z7kpc7w7y","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi4000b322zbuqgaivt"},{"post_id":"cljo05xhs0001322z4u4r9qol","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi5000f322z8fp5g6ho"},{"post_id":"cljo05xhv0002322zdvtod7w8","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi5000g322z5odw4k2s"},{"post_id":"cljo05xhz0005322zbms77p6a","category_id":"cljo05xhx0003322z3yxv71pz","_id":"cljo05xi6000i322ze3y10wuw"},{"post_id":"clkkjvrem0000602zb9xsgz3a","category_id":"clkkjvrer0002602zgg5oaqig","_id":"clkkjvrez0009602z357ndv67"},{"post_id":"clkkjvreq0001602z4v2x36q7","category_id":"clkkjvrer0002602zgg5oaqig","_id":"clkkjvrf0000c602z39xr94fa"},{"post_id":"clkkjvrew0004602zfgqk6s0d","category_id":"clkkjvrey0008602zhqrc6gsm","_id":"clkkjvrf0000e602zg3eee0ws"}],"PostTag":[{"post_id":"cljo05xi00006322z7kpc7w7y","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi30009322zhntdbae9"},{"post_id":"cljo05xhs0001322z4u4r9qol","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi4000a322z1vbrdpkq"},{"post_id":"cljo05xhv0002322zdvtod7w8","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi5000e322z349mdslj"},{"post_id":"cljo05xhz0005322zbms77p6a","tag_id":"cljo05xhy0004322zgvrl21g4","_id":"cljo05xi6000h322z0t6re9ey"},{"post_id":"clkkjvrem0000602zb9xsgz3a","tag_id":"clkkjvreu0003602zg2pm0j7d","_id":"clkkjvrey0007602zgwsj42ju"},{"post_id":"clkkjvreq0001602z4v2x36q7","tag_id":"clkkjvreu0003602zg2pm0j7d","_id":"clkkjvrez000b602zb46o56dt"},{"post_id":"clkkjvrew0004602zfgqk6s0d","tag_id":"clkkjvrez000a602zawb2c124","_id":"clkkjvrf0000d602z932ee3l9"}],"Tag":[{"name":"webpack","_id":"cljo05xhy0004322zgvrl21g4"},{"name":"FastAPI","_id":"clkkjvreu0003602zg2pm0j7d"},{"name":"PostgreSQL","_id":"clkkjvrez000a602zawb2c124"}]}}